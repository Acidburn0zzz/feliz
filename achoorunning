#!/bin/bash

# achoorunning - Functions called by the main achoo script while on auto
# Also declares all the global variables used throughout the scripts

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Evo/Lution script by Carl Duff and AUI scripts by HelmuthDU.

# Please read the introduction in the README file

#
# Partition variables
#
declare -a AddPartList	  # Array of additional partitions by system name. eg: /dev/sda5
declare -a AddPartMount   # Array of mountpoints for the same partitions in the same order. eg: /home
declare -a AddPartType  	# Array of format type for the same partitions. eg: ext4
declare -a PartitionArray # List of long identifiers for InfoMenu
declare -a NewArray       # For copying any array
declare -A LabellingArray # To hold full details of user labels for partitions
declare -A Labelled       # Store labels

SwapPartition=""  # "/dev/sda3"
FormatSwap="N"    # User selects whether to reuse swap
MakeSwap="Y"
SwapFile=""       # "2G"
IsSwap=""         # Result of lsblk test
RootPartition=""  # "/dev/sda2"
RootType=""       # "ext4"
Partition=""      # "sda1"

AutoPart=0        # Flag - changes to 1 if auto-partition is chosen
UseDisk="sda"     # Used if more than one disk
DiskDetails=0     # Size of selected disk
#
# Grub, kernel & EFI variables
#
GrubDevice=""     # "/dev/sda"
Kernel="1"        # Default 1 = LTS
IsInVbox=""       # Result of test to see if installation is in Virtualbox
DualBoot="N"      # Ready for dual-booting option
EFIPartition=""   # Will hold EFI partition mountpoint
#
# Location variables
#
CountryCode=""    # "GB" Country code for mirrorlist
CountryLocale=""  # "en_GB.UTF-8"	Locale
Countrykbd=""     # "uk" keyboard
ZONE=""           # "Europe" For time
SUBZONE=""        # "London" For time
#
# Desktop environment, display manager and greeter variables
#
DesktopEnvironment=""  # "xfce4"
GoodiesXfce=""
GoodiesGnome=""
GoodiesOpenbox=""
DisplayManager=""      # "lightdm"
Greeter=""             # "lightdm-gtk-greeter" (Not required for some DMs)
#
# Root and user variables
#
HostName=""  # "arch-linux"
UserName=""  # "archie"
Scope=""     # Installation scope ... 'Full' or 'Basic'
#
# Input/Output variables
#
OutPrompt="Press [Enter] to continue."
AnyPrompt="Press any key to continue."
Prompt1="Enter the number of your selection : "
Response="" # Global user input variable
Banner="~ https://wiki.archlinux.org ~"
Complete=0

# ---------------------
# Functions        Line
# ---------------------
# arch_chroot       80
# SetGrubDevice     89
# umount_partitions 117
# MountPartitions   136
# InstallKernel     214
# TestExistingDM    246
# SetRootPassword   275
# SetUserPassword   310
# ---------------------

arch_chroot() {  # Taken directly from Lution AIS
  arch-chroot /mnt /bin/bash -c "${1}" 2> error.log
  CheckForError "${LINENO} 'arch-chroot /mnt ${1}'" 2
}  

SetGrubDevice() {
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd')";
	print_heading
  GrubDevice=""
	Counter=0
	print_info "Select the device where Grub is to be installed."
  print_info "Note that if you select the 'Done' option, Grub will"
  print_info "not be installed, and you will have to make"
  print_info "alternative arrangements for booting your new system."
  echo
	Menu "${DevicesList}" "Enter the number of your selection: " "Devices"
  Reply=$Response
  for i in ${DevicesList}
	do
    Item=$i
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]; then
      if [ $Item = "Done" ]; then
        GrubDevice=""
      else
        GrubDevice=$Item
      fi
      break
  	fi
	done
}

umount_partitions(){ # from Lution/AUI
  MOUNTED=""
  MOUNTED=$(mount | grep "/mnt" | awk '{print $3}' | sort -r)
  swapoff -a 2> error.log
  CheckForError "${LINENO} 'swapoff'" 1
  for i in ${MOUNTED[@]}; do
    umount $i >/dev/null 2> error.log
    CheckForError "${LINENO} 'umount $i >/dev/null'" 1
  done
}

MountPartitions() {
  if [ ${UEFI} -eq 1 ] && [ ${DualBoot} = "N" ]; then
    mkfs.fat -F32 ${EFIPartition} 2> error.log
    CheckForError "${LINENO} 'mkfs.fat -F32 ${EFIPartition}'" 2
    mkdir /mnt/boot
  #  mount ${EFIPartition} /mnt/boot
  fi
  case $RootType in
    "") TPecho "Not formatting root partition"
    ;;
    *) TPecho "Formatting /root partition"
    # Check if replacing existing ext3/4 partition with btrfs
    CurrentType=`file -sL ${RootPartition} | grep 'ext\|btrfs' | cut -c26-30`
    if [ ${CurrentType} ] && [ $RootType = "btrfs" ] && [ ${CurrentType} != "btrfs" ]; then
      btrfs-convert ${RootPartition}
      CheckForError "${LINENO} 'btrfs-convert  ${RootPartition} $CurrentType ${RootType}'" 2
    elif [ $RootType = "btrfs" ]; then
      mkfs.btrfs -f ${RootPartition} 2> error.log
      CheckForError "${LINENO} 'mkfs.${RootType} ${RootPartition}'" 2
    else
      Partition=`echo $RootPartition | cut -c 6-`
      Label="${LabellingArray[${Partition}]}"
      if [ -n "${Label}" ]; then
        Label="-L ${Label}"
      fi
      mke2fs ${Label} -t ${RootType} ${RootPartition}
      CheckForError "${LINENO} 'mkfs.${RootType} ${RootPartition}'" 2
    fi
  esac
  TPecho "Mounting /root partition"	
  mount ${RootPartition} /mnt 2> error.log # eg: mount /dev/sda1 /mnt
  CheckForError "${LINENO} 'mount ${RootPartition} /mnt'" 2
  if [ ${SwapPartition} ]; then
    if [ $MakeSwap = "Y" ]; then
      TPecho "Making /swap partition"
      Partition=`echo $SwapPartition | cut -c 6-`
      Label="${LabellingArray[${Partition}]}"
      if [ -n "${Label}" ]; then
        Label="-L ${Label}"
      fi
      mkswap ${Label} ${SwapPartition} # eg: mkswap -L Arch-Swap /dev/sda2
      CheckForError "${LINENO} 'mkswap ${SwapPartition}'" 1
    fi
    TPecho "Activating /swap"
    swapon ${SwapPartition} 2> error.log # eg: swapon /dev/sda2
    CheckForError "${LINENO} 'swapon ${SwapPartition}'" 1
  fi
  TPecho "Mounting additional partitions"
  local Counter=0
  for id in ${AddPartList}
  do
    mkdir -p /mnt${AddPartMount[$Counter]} 2> error.log	# eg: mkdir -p /mnt/home
    CheckForError "${LINENO}" 0 # Non-critical, to allow for possible existing directory !!
    # Check if replacing existing ext3/4 partition with btrfs
    CurrentType=`file -sL ${AddPartType[$Counter]} | grep 'ext\|btrfs' | cut -c26-30`
    if [ ${AddPartType[$Counter]} = "btrfs" ] && [ ${CurrentType} != "btrfs" ]; then
      btrfs-convert ${id}
      CheckForError "${LINENO} 'btrfs-convert  ${id} $CurrentType ${AddPartType[$Counter]}'" 2
    elif [ ${AddPartType[$Counter]} = "btrfs" ]; then
      mkfs.btrfs -f ${id} 2> error.log
      CheckForError "${LINENO} 'mkfs.${AddPartType} ${id}'" 2
    elif [ ${AddPartType[$Counter]} != "" ]; then
      Partition=`echo ${id} | cut -c 6-`
      Label="${LabellingArray[${Partition}]}"
      if [ -n "${Label}" ]; then
        Label="-L ${Label}"
      fi
      mke2fs ${Label} -t ${AddPartType[$Counter]} ${id} # eg: mke2fs -L Arch-Home -t ext4 /dev/sda3
      CheckForError "${LINENO} 'mke2fs.${AddPartType[$Counter]} ${id}'" 2
    fi
    mount ${id} /mnt${AddPartMount[$Counter]} 2> error.log	# eg: mount /dev/sda3 /mnt/home
    CheckForError "${LINENO} 'mount ${id} /mnt${AddPartMount[$Counter]}'" 2
		Counter=$((Counter+1))
	done
}

InstallKernel() {
  TPecho "Installing kernel, base-devel & cli tools"
  # First, the modules used by both kernels
  pacstrap /mnt bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses logrotate lvm2 man-db man-pages mdadm nano netctl openssh pacman pciutils pcmciautils perl procps-ng psmisc reflector reiserfsprogs s-nail screenfetch sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi vim wget which xfsprogs base-devel btrfs-progs ntp sudo 2> error.log
  CheckForError "${LINENO} 'installing kernel and base-devel'" 2
  arch_chroot "systemctl enable sshd.service" >/dev/null
  if [ -z ${IsInVbox} ]; then # If not in Virtualbox
    pacstrap /mnt xf86-video-vesa xf86-video-nouveau 2> error.log # Install open video drivers
    CheckForError "${LINENO} 'Installing nouveau'" 1
  else
    # Add code to overcome piix4 Virtualbox error
    echo blacklist i2c_piix4 > /mnt/etc/modprobe.d/modprobe.conf 2> error.log
    CheckForError "${LINENO} 'vbox piix4 override'" 1
  fi
  # Then install the chosen kernel
  if [ $Kernel = "1" ]; then # LTS kernel
    pacstrap /mnt linux-lts
    CheckForError "${LINENO} 'installing lts kernel'" 2
    if [[ -n ${IsInVbox} ]]; then # If in Virtualbox
      pacstrap /mnt virtualbox-guest-modules-lts virtualbox-guest-utils-lts virtualbox-guest-dkms-lts
      CheckForError "${LINENO} 'Installing Virtualbox lts guest modules'" 1
    fi
  else # Latest kernel
    pacstrap /mnt linux
    CheckForError "${LINENO} 'installing latest kernel'" 2
    if [ -n ${IsInVbox} ]; then # If in Virtualbox
      pacstrap /mnt virtualbox-guest-modules virtualbox-guest-utils virtualbox-guest-dkms
      CheckForError "${LINENO} 'Installing Virtualbox guest modules'" 1
    fi
  fi
}

TestExistingDM() {
  # Test for existing display manager and disable if necessary
  arch-chroot /mnt touch etc/output.log # Create empty file
  arch-chroot /mnt systemctl list-unit-files | grep '(*dm|slim)\.service' > mnt/etc/output.log
  DMLine=`cat /mnt/etc/output.log`
  local Counter=1
  case ${DMLine} in
    "") TPecho "No previous DM discovered"
    ;;
    *) local Continue="Y"
      while [ ${Continue} = "Y" ]
      do
        ExDM=`echo $DMLine  | cut -f ${Counter} -d ' '` # First of pair is DM
        if [ -z ${ExDM} ]; then
          Continue="N" # Quit if no further entries
          break
        fi
        Counter=$((Counter+1))
        ExDMStatus=`echo $DMLine  | cut -f ${Counter} -d ' '` # Second is status
        case ${ExDMStatus} in
          "enabled") arch_chroot "systemctl disable ${ExDM}" >/dev/null
          ;;
          *) TPecho "${ExDM} already disabled"
        esac
        Counter=$((Counter+1))
      done
  esac
}

SetRootPassword() {
  print_heading
 	print_info  "Success! Finished installing in $DIFFMIN minutes and $DIFFSEC seconds"
  echo
 	print_info "Finally we need to set passwords ..."
  echo
  Repeat="Y"
  while [ $Repeat = "Y" ]
  do
    read -s -p "Enter a password for root: " Pass1
    echo
    read -s -p "Re-enter root password: " Pass2
    echo
    if [ -z ${Pass1} ] || [ -z ${Pass2} ]; then
      read_timed "Passwords cannot be blank. Try again ..." 1
      continue
    fi
    if [ $Pass1 = $Pass2 ]; then
     echo -e "${Pass1}\n${Pass2}" > /tmp/.passwd 2> error.log
     CheckForError "${LINENO} 'Root password'" 2
     arch_chroot "passwd root" < /tmp/.passwd >/dev/null
     rm /tmp/.passwd 2> error.log
     CheckForError "${LINENO} 'rm temp passwd'" 0
      Repeat="N"
    else
      print_heading
      print_info "Passwords don't match. Try again"
    fi
  done
}

SetUserPassword() {
  print_heading
  echo
	print_info   "And now a password for $UserName: "
  echo
  Repeat="Y"
  while [ $Repeat = "Y" ]
  do
    read -s -p "Enter a password for $UserName: " Pass1
    echo
    read -s -p "Re-enter password for $UserName: " Pass2
    echo
    if [ -z ${Pass1} ] || [ -z ${Pass2} ]; then
      read_timed "Passwords cannot be blank. Try again ..." 1
      continue
    fi
    if [ $Pass1 = $Pass2 ]; then
      echo -e "${Pass1}\n${Pass2}" > /tmp/.passwd 2> error.log
      CheckForError "${LINENO} 'save temp passwd'" 0
      arch_chroot "passwd ${UserName}" < /tmp/.passwd >/dev/null
      rm /tmp/.passwd 2> error.log
      CheckForError "${LINENO} 'rm temp passwd'" 0
      Repeat="N"
    else
      echo "Passwords don't match. Try again"
    fi
  done
}
