#!/bin/bash

# achoolux - Functions relevant to users, locations, desktop
# settings and data review called by the main achoo script
# 
# This script and the achooparts, achoorunning, achoodesktop and achoofuncs scripts
# must all be present in the same directory as the main achoo script when running.
# 
# Developed by Elizabeth Mills, incorporating some code adapted from
# the Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.
# 
# Please read the introduction in the main Achoo! script

# -------------------
# Functions      Line
# -------------------
# Variables       26
# PickLuxuries    69
# ShoppingList    99
# LibreVersion   170
# FinalCheck     193
# ManualSettings 269
# -------------------

Categories="Accessories Graphical Internet Multimedia Office Programming"
Accessories="conky gparted gnome-calculator nautilus terminator yaourt"
LongAccs[1]="Conky - Desktop time and system information"
LongAccs[2]="GParted - make/delete/resize partitions"
LongAccs[3]="gCalculator - Calculator for your taskbar"
LongAccs[4]="Nautilus - The file-manager from Gnome"
LongAccs[5]="Terminator - Multi-tab terminal emulator"
LongAccs[6]="Yaourt - Easy to use AUR package installer"
Graphical="evince gimp imagemagick gthumb simple-scan xsane"
LongGraph[1]="Evince - Reader for PDF and other document formats"
LongGraph[2]="GIMP - Advanced image editing suite"
LongGraph[3]="Imagemagick - Command-line image manipulation"
LongGraph[4]="gThumb - Image viewer & basic editor"
LongGraph[5]="Simple-Scan - A simple scanner GUI"
LongGraph[6]="Xsane - A full-featured GTK-based sane frontend"
Internet="chromium epiphany filezilla firefox qbittorrent thunderbird transmission-gtk"
LongNet[1]="Chromium - Open source web browser from Google       "
LongNet[2]="Epiphany - Gnome WebKitGTK+ browser (aka Web)"
LongNet[3]="Filezilla - Fast and reliable FTP, FTPS & SFTP client"
LongNet[4]="Firefox - Extensible browser from Mozilla"
LongNet[5]="qBittorent - Open source BitTorrent client"
LongNet[6]="Thunderbird - Feature-rich email client from Mozilla"
LongNet[7]="Transmission - Easy-to-use BitTorrent client"
Multimedia="avidemux-gtk banshee handbrake openshot vlc xfburn"
LongMulti[1]="Avidemux - Simple video editor                  "
LongMulti[2]="Banshee - Feature-rich audio player"
LongMulti[3]="Handbrake - Simple yet powerful video transcoder"
LongMulti[4]="Openshot - Easy-to-use non-linear video editor"
LongMulti[5]="VLC - Middleweight video player"
LongMulti[6]="Xfburn"
Office="abiword gnumeric libreoffice orage scribus"
LongOffice[1]="Abiword - Full-featured word processor            "
LongOffice[2]="Gnumeric - Spreadsheet program from GNOME"
LongOffice[3]="LibreOffice - Open-source office software suite"
LongOffice[4]="Orage - Calendar and task manager (incl with Xfce)"
LongOffice[5]="Scribus - Desktop publishing program"
Programming="bluefish codeblocks emacs geany git netbeans"
LongProg[1]="Bluefish - GTK+ IDE with support for Python plugins  "
LongProg[2]="Code::Blocks - Open source & cross-platform C/C++ IDE"
LongProg[3]="Emacs - extensible, customizable text editor"
LongProg[4]="Geany - Advanced text editor & IDE"
LongProg[5]="Git - open source distributed version control system"
LongProg[6]="Netbeans - Integrated development environment (IDE)"

PickLuxuries() {
# User selects any combination from a list of luxuries
local Complete=0
LuxuriesList=""
print_heading
print_info "Now you have the option to add 'luxuries' such as a"
print_info "web browser, office software, graphical tools, etc"
print_info "Yaourt is now optional, and is located in 'Accessories'"
echo
while [ $Complete -eq 0 ]
do
  Menu "$Categories" "Please choose a category: " "Categories"
  Category=$Response
  if [ $Result = "Done" ]; then
    break
  else
    ShoppingList
    print_heading
    print_info "Added so far: ${LuxuriesList}"
    echo
    print_info "You can now choose from any of the other lists,"
    print_info "or choose 'Done' to finish this part of the setup"
  fi
done
LuxuriesList="${LuxuriesList,,}"  #Safety net in case any items have caps
if [ -n "${LuxuriesList}" ]; then
  Scope="Extras"
fi
}

ShoppingList() {
# Called by PickLuxuries after a category has been chosen.
local Complete=0
Passed="Choose your first item"
# and will pass them on to InfoMenu for the user to choose one item;
# When control returns here, it is checked then added to the shopping list
# Then InfoMenu is called again until user selects "Done" 
while [ $Complete -eq 0 ]
do
  print_heading
  print_info "Added so far: ${LuxuriesList}"
  echo
  case $Category in
    1) InfoMenu "$Accessories" "Accessories" "LongAccs"
    ;;
    2) InfoMenu "$Graphical" "Graphical" "LongGraph"
    ;;
    3) InfoMenu "$Internet" "Internet" "LongNet"
    ;;
    4) InfoMenu "$Multimedia" "Multimedia" "LongMulti"
    ;;
    5) InfoMenu "$Office" "Office" "LongOffice"
    ;;
    6) InfoMenu "$Programming" "Programming" "LongProg"
    ;;
    *) break
  esac
  if [ $Result = "Done" ]; then
    break
  fi
  AddToList="Y"
  # First check that chosen item is not already on the list
  for lux in $LuxuriesList
  do
    if [ ${lux} = ${Result} ]; then
      read_timed "Already in your shopping list"
      AddToList="N"
    fi
  done
  # Then carry out any specific tests and add the item to the
  if [ ${AddToList} = "Y" ]; then
    if [ ${Result} = "libreoffice" ]; then
      LibreVersion
      case $Response in
        "5") LuxuriesList="${LuxuriesList} libreoffice-fresh"
        ;;   
        "4") LuxuriesList="${LuxuriesList} libreoffice-still"
        ;;
        *) echo "Wormhole detected"
      esac
    else
      LuxuriesList="${LuxuriesList} ${Result}"
    fi
  fi
  Passed="Choose your next item"
done
}

LibreVersion() {
  Redo="Y"
  Response="1"
  while [ $Redo = "Y" ]
  do
    print_heading
    print_info "LibreOffice was recently updated to version 5, but"
    print_info "some people still prefer the older version. So Achoo"
    print_info "gives you the option to choose."
    echo
    print_info "Version 5 (also called libreoffice-fresh)"
    print_list "Version 4 (now known as libreoffice-still)"
    echo
    TPread "Enter the version number you prefer (5 or 4) : "
    echo
    case $Response in
      "5" | "4") Redo="N"
      ;;
      *) invalid_option
    esac
  done
}

FinalCheck() {
Repeat=1
while [ $Repeat -gt 0 ]
do
  print_heading
  print_info "These are the settings you have entered. Please check them ..."
  echo
  print_info "1)  Root partition ... $RootPartition : $RootType" 50
  if [ $SwapPartition ] || [ $SwapFile ]; then
    print_list "2)  Swap partition ... $SwapPartition $SwapFile"
  else
    print_list "2)  No provision has been made for swap"
  fi
  if [ ${AddPartList} ]; then
    Counter=0
    print_list "3)  Extra partitions ..."
    for i in ${AddPartList[@]}	
    do
      print_info "     ${AddPartLabel[$Counter]} : ${AddPartList[$Counter]} : ${AddPartType[$Counter]}" 50
      Counter=$((Counter+1))
    done
  else
    print_list "3)  No additional partitions have been allocated"
  fi
  if [ $GrubDevice ]; then
  print_list "4)  Grub will be installed to $GrubDevice" 50
  else
    print_list "4)  No provision has been made for Grub"
  fi
  print_list "5)  Keyboard is $Countrykbd"
  print_list "6)  Locale will be set to $CountryLocale"
  print_list "7)  Zone/subZone will be $ZONE/$SUBZONE"
  if [ $DesktopEnvironment ] && [ $DisplayManager ]; then
    print_list "8)  DE = $DesktopEnvironment : $DisplayManager"
  elif [ $DesktopEnvironment ]; then
    print_list "8)  DE = $DesktopEnvironment $GoodiesGnome $GoodiesOpenbox $GoodiesXfce"
  else
    print_list "8)  No DE selected"
  fi
  print_list "9)  Root and user settings ..."
  print_list "     Hostname = '$HostName'"
  print_list "     User = '$UserName'"
  print_list "10) The following extras have been selected ..."
  print_list "     ${LuxuriesList}"
  echo
  print_list "Press [Enter] to install with these settings, or"
  TPread "enter an item number if you wish to change it: "
  Change=$Response
  case $Change in
    1) ChangeRootPartition
        AllocateRoot
    ;;
    2) ChangeSwapPartition
        AllocateSwap
    ;;
    3) ChangePartitions
        MorePartitions
    ;;
    4) SetGrubDevice
    ;;
    5) getkeymap
    ;;
    6) setlocale
    ;;
    7) SetTimeZone
    ;;
    8) ChooseDE
    ;;
    9) ManualSettings
    ;;
    10) PickLuxuries
    ;;
    *) Repeat=0
  esac
done
}

ManualSettings() {
  Retry="Y"
  Response=3
  while [ $Retry = "Y" ]
  do
    print_heading
    print_info "Enter number for data to change, or [Enter] to finish:"
    echo
    print_info "1) Hostname (currently $HostName)"
    print_list "2) Username (currently $UserName)"
    echo
    TPread "Enter the number of your selection : "
    echo
    case $Response in
      1) TPread "Enter new Hostname (currently $HostName) : "
         HostName=$Response
        ;;
      2) TPread "Enter new username to be created (currently $UserName) : "
         UserName=$Response
        ;;
      *) Retry="N"
         break
    esac
  done
}

ChangeRootPartition() {
# Start array with SwapPartition
  Ignorelist[0]=${SwapPartition}
  local Counter=1
  AddExtras
  MakePartitionList
}
  
ChangeSwapPartition() {
# Start array with RootPartition
  Ignorelist[0]=${RootPartition}
  Counter=1
  AddExtras
  MakePartitionList
}

ChangePartitions() {
# Copy RootPartition and SwapPartition into temporary array
Ignorelist[0]=${RootPartition}
local Counter=1
if [ ${SwapPartition} ]; then
  Ignorelist[1]=${SwapPartition}
  Counter=2
fi
Ignores=${#Ignorelist[@]} # Save a count for later
MakePartitionList
}

AddExtras() {
  # Called by ChangeSwapPartition and ChangeRootPartition with
  # Ignorelist started and Counter set to next record number
  # Add each field (extra partition) from AddPartList into the array:
  for a in ${AddPartList[@]}; do
    Ignorelist[$Counter]=$a
    Counter=$((Counter+1))
  done
  Ignores=${#Ignorelist[@]} # Save a count for later
}

MakePartitionList() {
  # Call function to generate an array of partitions
  # This is not a first call, so first empty the existing array
   	local x=0
    local HowMany="${#PartitionArray[@]}"
    until [ ${x} -eq ${HowMany} ]
    do
      unset PartitionArray[$x]
      x=$((x+1))
    done
		BuildPartitionLists # Then rebuild
}

