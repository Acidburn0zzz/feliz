#!/bin/bash

# achoodesktop - Functions relevant to users, locations, desktop
# settings and data review called by the main achoo script
# 
# This script and the achooparts, achoorunning and achoofuncs scripts must
# all be present in the same directory as the main achoo script when running.
# 
# Developed by Elizabeth Mills, incorporating some code adapted from
# the Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.
# 
# Please read the introduction in the main Achoo! script
# 

# -------------------
# Functions      Line
# -------------------
# Variables       26
# PickLuxuries    68
# CheckAndAdd    107  (see separate Manual)
# Multi-Menu     138
# LibreVersion   203
# FinalCheck     228
# ManualSettings 303
# -------------------

Categories="Accessories Graphical Internet Multimedia Office Programming"
Accessories="conky gparted gnome-calculator nautilus terminator yaourt"
LongAccs[1]="Conky - Desktop time and system information"
LongAccs[2]="GParted - make/delete/resize partitions"
LongAccs[3]="gCalculator - Calculator for your taskbar"
LongAccs[4]="Nautilus - The file-manager from Gnome"
LongAccs[5]="Terminator - Multi-tab terminal emulator"
LongAccs[6]="Yaourt - Easy to use AUR package installer"
Graphical="evince gimp imagemagick gthumb simple-scan xsane"
LongGraph[1]="Evince - Reader for PDF and other document formats"
LongGraph[2]="GIMP - Advanced image editing suite"
LongGraph[3]="Imagemagick - Command-line image manipulation"
LongGraph[4]="gThumb - Image viewer & basic editor"
LongGraph[5]="Simple-Scan - A simple scanner GUI"
LongGraph[6]="Xsane - A full-featured GTK-based sane frontend"
Internet="chromium epiphany filezilla firefox qbittorrent thunderbird transmission-gtk"
LongNet[1]="Chromium - Open source web browser from Google       "
LongNet[2]="Epiphany - Gnome WebKitGTK+ browser (aka Web)"
LongNet[3]="Filezilla - Fast and reliable FTP, FTPS & SFTP client"
LongNet[4]="Firefox - Extensible browser from Mozilla"
LongNet[5]="qBittorent - Open source BitTorrent client"
LongNet[6]="Thunderbird - Feature-rich email client from Mozilla"
LongNet[7]="Transmission - Easy-to-use BitTorrent client"
Multimedia="avidemux-gtk banshee handbrake openshot vlc xfburn"
LongMulti[1]="Avidemux - Simple video editor                  "
LongMulti[2]="Banshee - Feature-rich audio player"
LongMulti[3]="Handbrake - Simple yet powerful video transcoder"
LongMulti[4]="Openshot - Easy-to-use non-linear video editor"
LongMulti[5]="VLC - Middleweight video player"
LongMulti[6]="Xfburn"
Office="abiword gnumeric libreoffice orage scribus"
LongOffice[1]="Abiword - Full-featured word processor            "
LongOffice[2]="Gnumeric - Spreadsheet program from GNOME"
LongOffice[3]="LibreOffice - Open-source office software suite"
LongOffice[4]="Orage - Calendar and task manager (incl with Xfce)"
LongOffice[5]="Scribus - Desktop publishing program"
Programming="bluefish codeblocks emacs geany git netbeans"
LongProg[1]="Bluefish - GTK+ IDE with support for Python plugins  "
LongProg[2]="Code::Blocks - Open source & cross-platform C/C++ IDE"
LongProg[3]="Emacs - extensible, customizable text editor"
LongAccs[4]="Geany - Advanced text editor & IDE"
LongProg[5]="Git - open source distributed version control system"
LongProg[6]="Netbeans - Integrated development environment (IDE)"

PickLuxuries() {
# User selects any combination from a list of luxuries
local Complete=0
LuxuriesList=""
print_heading
print_info "Now you have the option to add 'luxuries' such as a"
print_info "web browser, office software, graphical tools, etc"
print_info "Yaourt is now optional, and is located in 'Accessories'"
while [ $Complete -eq 0 ]
do
  Menu "$Categories" "Please choose a category: "
  print_heading
   case $Response in
    1) Multimenu "$Accessories" "Added so far: ${LuxuriesList}" "Accessories" "LongAccs"
    ;;
    2) Multimenu "$Graphical" "Added so far: ${LuxuriesList}" "Graphical" "LongGraph"
    ;;
    3) Multimenu "$Internet" "Added so far: ${LuxuriesList}" "Internet" "LongNet"
    ;;
    4) Multimenu "$Multimedia" "Added so far: ${LuxuriesList}" "Multimedia" "LongMulti"
    ;;
    5) Multimenu "$Office" "Added so far: ${LuxuriesList}" "Office" "LongOffice"
    ;;
    6) Multimenu "$Programming" "Added so far: ${LuxuriesList}" "Programming" "LongProg"
    ;;
    *) break
  esac
  print_heading
  print_info "Added so far: ${LuxuriesList}"
  echo
  print_info "You can now choose from any of the other lists,"
  print_info "or choose 'Done' to finish this part of the setup"
done
LuxuriesList="${LuxuriesList,,}"  #Safety net in case any items have caps
if [ -n "${LuxuriesList}" ]; then
  Scope="Extras"
fi
}

CheckAndAdd() {
# Called from Multi-Menu. Adds item(s) to a variable specific to the
# function that called Multi-Menu (in this instance it is for PickLuxuries)
Caller="PickLuxuries"
AddToList="Y"
# First check that chosen item is not already on the list
for lux in $LuxuriesList
do
  if [ ${lux} = ${Result} ]; then
    read_timed "Already in your shopping list"
    AddToList="N"
  fi
done
# Then carry out any specific tests and add the item to the
if [ ${AddToList} = "Y" ]; then
    if [ ${Result} = "libreoffice" ]; then
      LibreVersion
      case $Response in
        "5") LuxuriesList="${LuxuriesList} libreoffice-fresh"
        ;;   
        "4") LuxuriesList="${LuxuriesList} libreoffice-still"
        ;;
        *) echo "Wormhole detected"
      esac
    else
      LuxuriesList="${LuxuriesList} ${Result}"
    fi
  Passed="Added so far: ${LuxuriesList}"  
fi
}

Multimenu() {
# Menu, with extended descriptions linked to app name
# Parameters: 1) Primary file; 2) Copy of existing output file;
# 3) Title; 4) Secondary file (long description); 
local Complete=0
Result=""
PrimaryFile="$1"
Passed="$2"
name=$4[@]
LongDescription=("${!name}")
local Counter=0
while [ $Complete -eq 0 ]
do
  print_heading
  print_info "$Passed"
  echo
  print_info "Please select one item at a time from this list"
  print_info "by entering its number and pressing [Enter]"
  echo
  print_info "$3"
  Underscore=`echo $3 | sed 's/./-/g'`
  print_info "$Underscore"
  Counter=0
  # for i in $PrimaryFile; do
  for i in "${LongDescription[@]}"; do
    Counter=$((Counter+1))
    if [ $Counter -eq 1 ]; then
      print_info "${Counter}) $i"
    else
      print_list "${Counter}) $i"
    fi
  done
  Counter=$((Counter+1))
  print_list "$Counter) Done"
  echo
  TPread "Please enter one number : "
  if [ -z ${Response} ] || [ ${Response} = ${Counter} ]; then
    Result="Done"
    Complete=1
  elif [ ${Response} -gt ${Counter} ] || [ ${Response} -lt 1 ]; then
    invalid_option
  else
    Counter=0
    for i in $PrimaryFile; do
      Counter=$((Counter+1))
      if [ $Counter -eq $Response ]; then
        Result="$i"
      fi
    done
    CheckAndAdd
  fi
done
}

LibreVersion() {
  Redo="Y"
  Response="1"
  while [ $Redo = "Y" ]
  do
    print_heading
    print_info "LibreOffice was recently updated to version 5, but"
    print_info "some people still prefer the older version. So Achoo"
    print_info "gives you the option to choose."
    echo
    print_info "Version 5 (also called libreoffice-fresh)"
    print_list "Version 4 (now known as libreoffice-still)"
    echo
    TPread "Enter the version number you prefer (5 or 4) : "
    echo
    case $Response in
      "5" | "4") Redo="N"
      ;;
      *) invalid_option
    esac
  done
}

FinalCheck() {
Repeat=1
while [ $Repeat -gt 0 ]
do
  print_heading
  print_info "These are the settings you have entered. Please check them ..."
  echo
  print_info "1)  Root partition ... $RootPartition : $RootType" 50
  if [ $SwapPartition ] || [ $SwapFile ]; then
    print_list "2)  Swap partition ... $SwapPartition $SwapFile"
  else
    print_list "2)  No provision has been made for swap"
  fi
  if [ ${AddPartList} ]; then
    Counter=0
    print_list "3)  Extra partitions ..."
    for i in ${AddPartList[@]}	
    do
      print_info "     ${AddPartLabel[$Counter]} : ${AddPartList[$Counter]} : ${AddPartType[$Counter]}" 50
      Counter=$((Counter+1))
    done
  else
    print_list "3)  No additional partitions have been allocated"
  fi
  if [ $GrubDevice ]; then
  print_list "4)  Grub will be installed to $GrubDevice" 50
  else
    print_list "4)  No provision has been made for Grub"
  fi
  print_list "5)  Keyboard is $Countrykbd"
  print_list "6)  Locale will be set to $CountryLocale"
  print_list "7)  Zone/subZone will be $ZONE/$SUBZONE"
  if [ $DesktopEnvironment ] && [ $DisplayManager ]; then
    print_list "8)  DE = $DesktopEnvironment : $DisplayManager"
  elif [ $DesktopEnvironment ]; then
    print_list "8)  DE = $DesktopEnvironment $GoodiesGnome $GoodiesOpenbox $GoodiesXfce"
  else
    print_list "8)  No DE selected"
  fi
  print_list "9)  Root and user settings ..."
  print_list "     Hostname = '$HostName'"
  print_list "     User = '$UserName'"
  print_list "10) The following extras have been selected ..."
  print_list "     ${LuxuriesList}"
  echo
  print_list "Press [Enter] to install with these settings, or"
  TPread "enter an item number if you wish to change it: "
  case $Response in
    1) ChangeRootPartition
        AllocateRoot
    ;;
    2) ChangeSwapPartition
        AllocateSwap
    ;;
    3) ChangeExtraPartitions
        ExtraPartitions
    ;;
    4) SetGrubDevice
    ;;
    5) getkeymap
    ;;
    6) setlocale
    ;;
    7) SetTimeZone
    ;;
    8) ChooseDE
    ;;
    9) ManualSettings
    ;;
    10) PickLuxuries
    ;;
    *) Repeat=0
  esac
done
}

ManualSettings() {
  Retry="Y"
  Response=3
  while [ $Retry = "Y" ]
  do
    print_heading
    print_info "Enter number for data to change, or [Enter] to finish:"
    echo
    print_info "1) Hostname (currently $HostName)"
    print_list "2) Username (currently $UserName)"
    echo
    TPread "Enter the number of your selection : "
    echo
    case $Response in
      1) TPread "Enter new Hostname (currently $HostName) : "
         HostName=$Response
        ;;
      2) TPread "Enter new username to be created (currently $UserName) : "
         UserName=$Response
        ;;
      *) Retry="N"
         break
    esac
  done
}

ChangeRootPartition() {
# Start array with SwapPartition
  Ignorelist[0]=${SwapPartition}
  local Counter=1
  AddExtras
  MakePartitionList
}
  
ChangeSwapPartition() {
# Start array with RootPartition
  Ignorelist[0]=${RootPartition}
  Counter=1
  AddExtras
  MakePartitionList
}

ChangeExtraPartitions() {
# Copy RootPartition and SwapPartition into temporary array
Ignorelist[0]=${RootPartition}
local Counter=1
if [ ${SwapPartition} ]; then
  Ignorelist[1]=${SwapPartition}
  Counter=2
fi
Ignores=${#Ignorelist[@]} # Save a count for later
MakePartitionList
}

AddExtras() {
  # Called by ChangeSwapPartition and ChangeRootPartition with
  # Ignorelist started and Counter set to next record number
  # Add each field (extra partition) from AddPartList into the array:
  for a in ${AddPartList[@]}; do
    Ignorelist[$Counter]=$a
    Counter=$((Counter+1))
  done
  Ignores=${#Ignorelist[@]} # Save a count for later
}

MakePartitionList() {
  # Get a new list of all available partitions ...
  Partitionlist=$(lsblk -l | grep 'part' | sed 's/[\t ].*//')
  # Make an array
  Counter=0
  for a in $Partitionlist; do
    AllPartitions[$Counter]=$a
    Counter=$((Counter+1))
  done
  # Parse through AllPartitions, comparing against each item in Ignorelist
  PartitionList=""
  use=1
  for a in ${AllPartitions[@]}; do
    for i in ${Ignorelist[@]}; do
      if [ $i = $a ]; then
        use=0
        break
      fi
    done
    if [ ${use} -eq 1 ]; then
      PartitionList="${PartitionList} $a"
    else
      use=1
    fi
  done
}

