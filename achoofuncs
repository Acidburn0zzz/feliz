#!/bin/bash

# Achoo! Arch Linux Installation Script 2015/07/16
# achoofuncs - Functions called by the main Achoo! script
# -----------------------------------------------------------
# This script and the achoovariables script must be present in the same
# directory when running the main Achoo! script
# -----------------------------------------------------------

# Developed by Elizabeth Mills, incorporating some code adapted from the
# Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.

# The Achoo! script is still in development, and may contain bugs.
# It was originally written for my own use, but it is shared in the spirit of
# the community, subject to the conditions set out in the GNU GENERAL LICENSE.
# Its purpose is to speed up installation of Arch Linux, plus a desktop
# environment and a greeter, with minimum user intervention.

# Users - You must plan your partition scheme and take care when entering
# your details, or loss of data could occur.

# -------------------------
# Functions           Line
# -------------------------
# Input and output     35
# Error-checking       88
# Mirrorlist           119
# Partitioning         150
# User & Location      525
# Desktop Environment  704
# Running              789
# ------------------------

# ----------------
# Input and output 
# ----------------

contains_element() { # (from AUI scripts)
# check if an element exists in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    print_line
    echo 
    read -t 2 -p "Invalid option. Try another one."
}

print_heading() {
  clear
  #_WINDOW_X=`tput lines`
  _WINDOW_Y=`tput cols`
  tput setf 6 # 0:Black 1:Blue 2:Green 3:Cyan 4:Red 5:Magenta 6:Yellow 7:White
  tput cup 1 $((($_WINDOW_Y/2)-20))
  printf "~ The Achoo! Arch Linux Installation Script ~ \n"
  printf "%$(tput cols)s\n"|tr ' ' '-'
  if [ $_WINDOW_Y -gt 90 ]; then
    tput cup 3 $((($_WINDOW_Y/2)-45))
    printf  "~  https://www.facebook.com/groups/915936978471838/ ~ https://wiki.archlinux.org/ ~ \n"
  elif [ $_WINDOW_Y -gt 40 ]; then
    tput cup 3 $((($_WINDOW_Y/2)-15))
    printf  "~ https://wiki.archlinux.org/ ~ \n"
  else
    printf  "https://wiki.archlinux.org/ \n"
  fi
  printf "%$(tput cols)s\n"|tr ' ' '-'
  tput sgr0
}

print_line() { # (from AUI scripts)
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() { # (from AUI scripts)
    print_line
    echo -e " ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() { # (from AUI scripts)
    # Console width number
    T_COLS=`tput cols`
    echo -e "$1 \n" | fold -sw $(( $T_COLS - 10 )) | sed 's/^/\t/'
}

read_timed() {
  echo $1
  read -t 2 -p ""
}

# --------------
# Error-checking
# --------------

CheckForError() {
# Check for stderr, display it, then exit script
# Now receiving $2 to flag critical or non-critical error
	if [[ $? -gt 0 ]]; then
    clear
		echo "Error reported at Line: $1"
    cat error.log
    case $2 in
      0) print_info "The error is not critical, and you may ignore it"
      ;;
      1) print_info "You may ignore the error if you choose"
      print_info "but this may have unexpected consequences"
      read -p "   Continue with installation? (y/N): " Response
      case $Response in
        "n" | "N" | "") exit
        ;;
        *) echo ""
      esac
      ;;
      *) print_info "The error is critical, and the script cannot continue"
        read -n1 -p "   Please press any key: "
        exit
    esac
    print_info "Continuing as though nothing has happened"
  fi
}

# -----------------------
# Mirrorlist
# -----------------------

LocalMirrorList() {
# Generate and save a shortened mirrorlist of only the mirrors defined
# in the CountryCode variable. Adapted from Lution AIS
	print_info "Generating local mirrorlist"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist) 2> error.log
	CheckForError "${LINENO}"
	
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL} 2> error.log
	CheckForError "${LINENO}" 2
	
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp} 2> error.log
	CheckForError "${LINENO}" 2
	
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig 2> error.log
	CheckForError "${LINENO}" 2
	
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist 2> error.log
	CheckForError "${LINENO} 'saving mirrorlist'" 2
	chmod +r /etc/pacman.d/mirrorlist 2> error.log
	CheckForError "${LINENO} 'saving mirrorlist'" 2
}

# ------------
# Partitioning
# ------------

ManagePartitions() {
# Check and show partitions ... call cfdisk
	# First test for existing partitions
	print_heading
	ShowPartitions=""
	PARTITIONS=""
	ShowPartitions=$(lsblk -l | grep 'part' | sed 's/[\t ].*//')
	# Count the partitions
  for i in ${ShowPartitions[@]}; do
    PARTITIONS="${PARTITIONS} ${i} -"
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
  done	
	# If no partitions exist, offer cfdisk to create (or exit)
	if [[ $NUMBER_PARTITIONS -eq 0 ]]; then
		print_heading
    echo
    print_info "There are no partitions on the device. 'cfdisk' is available for you to"
    print_info "create a partition table now if you wish."
    echo 
    print_info "Please note:"
    print_info "  At least one partition, for the / (root) directory, must be created."
    print_info "  Achoo! does not, as yet, support the UEFI/GPT partition table."
    print_info "  If you are uncertain about partitioning, you should read the Arch Wiki."
    print_info "  If you choose not to use 'cfdisk' now, the script will terminate, to"
    print_info "     allow you to partition in some other way."
    echo
    read -p "   Would you like to open cfdisk now? [Y/n]: " Response
    case $Response in
		  "y"|"Y"|"") cfdisk 2> error.log
      	CheckForError "${LINENO} 'cfdisk'" 2
			;;
		*) exit
		esac
 	else
    # Alternatively, offer cfdisk to edit existing partitions
		echo -e "   Here is a list of available partitions on all connected devices ... \n"
		lsblk
		echo ""
		read -p "   Would you like to open cfdisk to manage those partitions now? [Y/n]: " Response
		case $Response in
		  "y"|"Y"|"") cfdisk 2> error.log
            	CheckForError "${LINENO} 'cfdisk'" 2
			;;
      *) echo ""
		esac
	fi
  # After cfdisk, build new list of partitions
  PartitionList=" "
  ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//')
  for Part in ${ShowPartitions}
  do
    PartitionList="$PartitionList $Part"	# Add each partition
  done
}

select_filesystem() {
# Adapted from Lution
# Allows user-selection of filesystem by entering a number
# Returns enhanced selection via FILESYSTEM variable
	local Counter=0
	PS3="$prompt1"
#	TypeList now passed by caller
	echo -e "   Now select the file system for ${Partition} \n"
	select type in ${TypeList}
	do
    for i in ${TypeList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				PartitionType=$i
        break
			fi
		done
		break
  done
}

AllocateRoot() {
# Display partitions for user-selection	
	# Uses list of all available partitions in PartitionList created in ManagePartitions
	print_heading
	Remaining=""
	local Counter=0
  Partition=""
	PartitionType=""
	PS3="$prompt1"
	echo -e "   Here are the partitions that are available. \n"
	echo -e "   First you should select one to use for root: \n"
	select partition in ${PartitionList}
	do
    Reply=$REPLY
    for i in ${PartitionList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
				Partition="/dev/$i"
				RootPartition="${Partition}"
        # Before going to select_filesystem, check the partition
        CheckPartition
        if [ ${CurrentType} ]; then
          print_info "You can choose to leave it as it is, by selecting 'Skip', but not"
          print_info "reformatting the root partition can have unexpected consequences."
          echo
          TypeList="Skip ext2 ext3 ext4 btrfs"	
        else
        	TypeList="ext2 ext3 ext4 btrfs"	
        fi
        # Now select a filesystem
 				select_filesystem
				if [ -z ${PartitionType} ]
				then
					RootType="ext4"
				else
          RootType="${PartitionType}"
        fi
			else
				Remaining="$Remaining $i"	# Add next available partition
			fi
		done
    PartitionList=$Remaining			# Replace original PartitionList with remaining options
		break
  done
}

CheckPartition() {
# Finds if there is an existing file system on the selected partition
print_heading
# CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
if [ ${CurrentType} ]; then
  print_info "The selected partition ${Partition} is currently formatted to ${CurrentType}"
  echo -e "   Reformatting it will remove all data currently on it. \n"
fi
}

AllocateSwap() {
# Checks if there are remaining partitions from AllocateRoot, and allows selection for swap
print_heading
if [ -n ${#PartitionList[@]} ]
then
  echo -e "   Select the partition for /swap from the ones that remain,"
  echo -e "   or allocate a swap file. \n"
  Remaining=""
  local Counter=0
  PS3="$prompt1"
  SwapPartition=""
  PartitionList="Skip $PartitionList Swapfile"
  SwapFile=""
  echo -e "   If you select the 'Skip' option, no swap will be allocated: \n"
  select partition in ${PartitionList}
  do
  Reply=$REPLY
  echo ""
    for i in ${PartitionList}
    do
      Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        case $i in
          "Skip") SwapPartition=""
          ;;
          "Swapfile") SetSwapFile
                SwapPartition=""
          ;;
          *)  SwapPartition="/dev/$i"
        esac          
      else
        if [ $i != Skip ] && [ $i != Swapfile ]; then
          Remaining="$Remaining $i"	# Add next available partition
        fi
      fi
    done
    break
  done
  if [ $SwapPartition ]; then
      read -t 2 -p "   $SwapPartition will be used for swap."
  elif [ $SwapFile ]; then
      read -t 2 -p "   A swap file of ${SwapFile} will be allocated."
  else
      read -t 2 -p "   No swap partition will be allocated."
  fi
  echo
  PartitionList=$Remaining		# Replace original PartitionList with remaining options
fi
}

SetSwapFile() {
# If user chooses to have a swap file instead of swap partition
LoopRepeat="Y"
while [ ${LoopRepeat} = "Y" ]
do
	print_info "Allocate the size of your swap file (M = Megabytes, G = Gigabytes)"
  read -p "Size of swap file [eg: 512M or 2G]: " Response
  RESPONSE="${Response^^}"
	# Check that entry includes 'M or G'
	CheckInput=(`echo $RESPONSE | grep "G\|M"`)
  echo ""
	if [ -z ${CheckInput} ]; then
    print_info "You must include M or G"
		SwapFile=""
	else
    SwapFile=$RESPONSE
    LoopRepeat="N"
  fi
  if [ ${LoopRepeat} = "N" ]  
  then
    break
  fi 
done 
}

ExtraPartitions() {
# If partitions on the device remain unselected
local PartCounter=0
AddedToRemaining=0
Elements=${#PartitionList[@]}
while [ $PartCounter -le $Elements ] # Display a list (including a 'Skip' option) 
do
	print_heading
	Remaining=""
	PS3="$prompt1"
  PartitionList="Skip $PartitionList"
	print_info "The following partitions remain unallocated. If you wish to use one,"
  echo -e "   select it from the list, or choose 'Skip' to exit. \n"
	select partition in ${PartitionList} # User select an item from the list
	do
  echo
  Selected=$REPLY
		for Part in ${PartitionList} # Iterate through the list
		do
      Partition=""
      PartitionType=""
      PartCounter=$((PartCounter+1))
			if [ $PartCounter -eq $Selected ]
			then
        Item=$Part  # Selected item
        if [ $Item = Skip ]; then
          break
        else                        # If item is not 'Skip'
        	Partition="/dev/$Item"
          MakePartition # Call MakePartition to complete details
        fi
      else                          # If $Counter is not equal to $Selected
        if [ $Part != Skip ]; then   # (and not 'Skip')
          Remaining="$Remaining $Part" # Add unused partition to temp list
          AddedToRemaining=$(($AddedToRemaining+1))
        fi
			fi
    done
    if [ $Part = Skip ] || [ ${AddedToRemaining} -eq 0 ]; then  # If skip or there are no more to allocate
      break
    fi
    break
  done
  if [ $Item = Skip ] || [ ${AddedToRemaining} -eq 0 ]; then
    break
  fi
  PartCounter=0 # Final breakpoint, when all required partitions have been selected
  PartitionList=$Remaining	# Replace original PartitionList with temp list
  Elements=${#PartitionList[@]}
done
# Ensure that if AddPartList (the defining array) is empty, all others are too
if [ -z ${#AddPartList[@]} ]
then
  AddPartList=""
  AddPartLabel=""
  AddPartType=""
fi

}

MakePartition() {
  # 1) When selected, first save to AddPartList (eg: /dev/sda5)
	ExtraPartitions=${#AddPartList[@]}
	AddPartList[$ExtraPartitions]="${Partition}"
  # 2) Then get a label for selected partition (eg: /home)
	LoopRepeat="Y"
	while [ ${LoopRepeat} = "Y" ]
	do
		print_info "Enter a label for ${Partition} ... eg: '/home' ... "
    read -p "  (you must include the '/'): " Response
		# Check that entry includes '/'
		CheckInput=(`echo $Response | cut -c1`)
		case ${CheckInput} in
      "") print_info "You must enter a valid name"
					PartLabel=""
          ;;
			*) if [ ${CheckInput} != "/" ]; then
						PartLabel="/${Response}"
				else
						PartLabel="${Response}"
				fi
    esac
    # Check that the label has not already been used
		LabelCounter=0
		if [ -z ${AddPartLabel} ]; then
			LoopRepeat="N"
		else
      # Go through AddPartLabel checking each item against PartLabel
			for Label in ${AddPartLabel}
			do 
				LabelCounter=$((LabelCounter+1))
				if [ $Label = $PartLabel ]; then
					read -t 4 -p "  Label ${PartLabel} has already been used. Please use a different label."
				else
					LoopRepeat="N"
					break
				fi
			done 
		fi 
		if [ ${LoopRepeat} = "N" ]  
		then
			break
		fi 
	done 
	AddPartLabel[$ExtraPartitions]="${PartLabel}" 	# Add it to AddPartLabel list
  CheckPartition   # Before going to select_filesystem, check the partition
  if [ ${CurrentType} ]; then
    print_info "You can choose to leave it as it is, by selecting 'Skip', but not"
    print_info "reformatting an existing partition can have unexpected consequences."
    echo
  fi
  TypeList="Skip ext2 ext3 ext4 btrfs" # Set format types for the selected partition
	select_filesystem
  if [ -z ${PartitionType} ]; then
		PartitionType="Skip"
	fi
	AddPartType[$ExtraPartitions]="${PartitionType}" 	# Add it to AddPartType list
}

# User to choose device for grub installation
SetGrubDevice() {
  # Store available devices in a list	
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd') Skip";
	# Display available devices and select one for Grub
	print_heading
  GrubDevice=""
	Counter=0
	PS3="$prompt1"
	print_info "Select the device where Grub is to be installed. Note that, if you"
  print_info "select the 'Skip' option, Grub will not be installed, and you will"
  print_info "have to make alternative arrangements for booting your new system."
	select partition in ${DevicesList}
	do
  Reply=$REPLY
    for i in ${DevicesList}
		do
    Item=$i
  	Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
        if [ $Item = Skip ]; then
        GrubDevice=""
        else
        GrubDevice=$Item
        fi
      break
    	fi
 		done
    break
  done
}

# ------------------------------
# Locations, Names and Passwords
# ------------------------------

getkeymap() {
# New routine to enable user to input two-letter country-code to find keyboard
print_heading
DoDoDo=1
print_info "Now we will try to find your keyboard from a list of all known"
print_info "layouts. If you know your keyboard code, enter it now. Alternatively, "
SearchPrompt="enter the two-letter code for your country (eg: uk or us): "
while [ $DoDoDo -eq 1 ]
do
  PS3="$prompt1"
  read -p "   $SearchPrompt" search_term
  echo
  SEARCHTERM="${search_term,,}"
  KeyboardList=('Try_Again' `localectl list-keymaps | grep ${SEARCHTERM} | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'` );
  echo
  print_info "Choose your keyboard, or 'Try_Again': "
  echo
  select KEYMAP in "${KeyboardList[@]}"; do
    if contains_element "$KEYMAP" "${KeyboardList[@]}"
    then
      if [ $KEYMAP = "Try_Again" ]
      then
        print_heading
        print_info "Try a different two-letter code: "
        break
      else
        Countrykbd=$KEYMAP
        DoDoDo=0
        break
      fi
    else
      invalid_option
    fi
  done
done
}

setlocale() {
# New routine to enable user to input two-letter country-code to find locale
print_heading
PS3="$prompt1"
DoDoDo=1
SearchPrompt="Enter the two-letter code for your country or language (eg: GB or en): "
print_info "Next we will try to find your locale"
while [ $DoDoDo -eq 1 ]
do
  read -p "   $SearchPrompt" search_term
  echo
  SEARCHTERM=${search_term}
  LocaleList=(`cat /etc/locale.gen | grep ${SEARCHTERM}....UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
 Counter=${#LocaleList[@]}
  if [ $Counter -eq 0 ]
  then 
    SEARCHTERM="${search_term^^}"
    LocaleList=(`cat /etc/locale.gen | grep ${SEARCHTERM}.UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    Counter=${#LocaleList[@]}
  fi
  Counter=$((Counter+1))
  LocaleList[$Counter]='Try_Again'
  echo
  print_info "Choose your locale, or 'Try_Again': "
  echo
  select LOCALE in "${LocaleList[@]}"; do
    if contains_element "$LOCALE" "${LocaleList[@]}"
    then
      if [ $LOCALE = "Try_Again" ]
      then
        print_heading
        print_info "Try a different two-letter code (try UPPER CASE): "
        break
      else
        CountryLocale="${LOCALE}.UTF-8"
        CountryCode=(`echo $LOCALE | cut -c4-6`)
        DoDoDo=0
        break
      fi
    else
      invalid_option
    fi
  done
done

}

settimezone() {
# Variables "ZONE" and "SUBZONE" - Defaults = "Europe/London"
print_heading
print_info "Now we have to set up the best mirrors for downloading your system"
print_info "This will also be used for setting the clock during installation"
print_info "Choose the World Zone of your location from the following list"
# Set Zone and Sub-Zone from lists (from AUI)
  local _zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
  PS3="$prompt1"
  print_info "Select zone:"
  select ZONE in "${_zones[@]}"
  do
    if contains_element "$ZONE" "${_zones[@]}"; then
      local _subzones=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
      print_heading
      PS3="$prompt1"
      echo -e "   Now select your local city or Sub-Zone: \n"
      select SUBZONE in "${_subzones[@]}"; do
        if contains_element "$SUBZONE" "${_subzones[@]}"; then
          break
        else
          invalid_option
        fi
      done
      break
    else
      invalid_option
    fi
  done
}

UserAndRoot() {
# Accept user input of hostname, username, user password and root password
	while [ $Repeat ]
	do
		# Hostname
		Entered="ArchLinux"
		print_heading
		print_info "A hostname is needed. This will be a unique name to identify"
		print_info "your device on a network. If you do not enter one, the default"
		print_info "hostname of 'ArchLinux' will be used."
		read -p "Enter a hostname for your computer : " Entered
		case $Entered in
			"") Entered=$HostName
			;;
			*) HostName=${Entered}
		esac
		print_info "Hostname set to: $HostName"
		# Username
		print_heading
		Entered="Archie"
		print_info "Next we have to deal with names and passwords."
		print_line
		print_info "If you don't create a username here, a default user called"
    print_info "'archie' will be set up"
		read -p "   Enter a username (must be all lower case): " Entered
		case $Entered in
			"") Entered=$UserName
			;;
			*) UserName=${Entered}
		esac
		print_info "Username set to: $UserName"
  	# User password
		print_heading
		Entered="Linux"
		print_info "Passwords should be a mixture of upper- and lower-case letters"
		print_info "plus numbers and special characters. If you do not enter"
		print_info "a user password, the default of 'Linux' will be used."
		read -p "Enter a password for $UserName: " Entered
		case $Entered in
			"") Entered=$UserPassword
			;;
			*) UserPassword=${Entered}
		esac
		print_info "User password set to: $UserPassword}"
		# Root password
		print_heading
		Entered="Root"
		print_info "Now set a password for root. If you do not enter one, a default"
    print_info "password of 'Root' will be used."
		read -p "   Enter a password for root: " Entered
		case $Entered in
			"") Entered=$RootPassword
			;;
			*) RootPassword=${Entered}
		esac
		print_info "Root password set to: $RootPassword"
	break
	done
}

# -------------------
# Desktop Environment
# -------------------

ChooseDE() {
	Counter=0
	PS3="$prompt1"
	DEList="LXDE LXQt Mate Xfce Skip"
  print_heading
  print_info "This installer offers only the 'lightweight' Desktop Environments."
  print_info "Mate and Xfce include many of the essential desktop tools, whereas LXDE and LXQt are basic desktops onto which you can add your choice of tools."
  print_info "Note that LXDE and LXQt include the Openbox window manager - useful for building your own desktop."
  print_info "Or you can choose to skip this option and install something else manually later."
  echo
	print_info "Choose your Desktop Environment"
	select type in ${DEList}
	do
  Reply=$REPLY
  SelectedDE=type
    for i in ${DEList}
    do
      Item=$i
      Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
      DesktopEnvironment=$Item
      case $Item in
        "LXDE") DisplayManager=""
              Greeter=""
          ;;
        "LXQt") DisplayManager="sddm"
              Greeter=""
          ;;
        "Mate") DMList="LightDM LXDM Skip"
              ChooseDM
          ;;
        "Xfce") DMList="LightDM LXDM Skip"
              ChooseDM
          ;;
        *) DesktopEnvironment=""
            DisplayManager=""
              Greeter=""	
 			esac
      break
			fi
		done
		break
  done
}

ChooseDM() {
  # Choice of Display Manager from list passed via DMList
  Counter=0
  PS3="$prompt1"
  print_heading
  print_info "Choose one of the following Display Managers for "$Item
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
  echo
  print_info "Choose your Display Manager"
  select type in ${DMList}
  do
  Reply=$REPLY
    for item in ${DMList}
    do
      Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        SelectedDM=$item
        case $SelectedDM in
          "LightDM") DisplayManager="lightdm"
                Greeter="lightdm-gtk-greeter"	
              ;;
          "LXDM") DisplayManager="lxdm"
                Greeter=""
              ;;
          *) DisplayManager=""
                Greeter=""
        esac	
        break
      fi
    done
		break
  done
}

# -------
# Running
# -------

arch_chroot() {
# Taken directly from Lution AIS
# Function chroots to MOUNTPOINT (/mnt) for parameter passed from caller
  arch-chroot ${MOUNTPOINT} /bin/bash -c "${1}" 2> error.log
  CheckForError "${LINENO} 'arch-chroot ${MOUNTPOINT} ${1}'" 2
}  

# Unmount partitions (from Lution/AUI - Nice code)
# 1) Gets a list of all mounted partitions into MOUNTED
# 2) Sets swap off for all devices marked as 'swap' in /etc/fstab
# 3) Unmounts each mounted device in turn from MOUNTED
umount_partitions(){
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a 2> error.log
  CheckForError "${LINENO} 'swapoff'" 2
  for i in ${MOUNTED[@]}; do
    umount $i >/dev/null 2> error.log
    CheckForError "${LINENO} 'umount $i >/dev/null'" 2
  done

}

MountPartitions() {
  # Root
  case $RootType in
    "") echo "Not formatting root partition"
    ;;
    "Skip") echo "Not formatting root partition"
    ;;
    *) echo "Formatting /root partition"
    mkfs.${RootType} ${RootPartition} 2> error.log # eg: mkfs.ext4 /dev/sda1
    CheckForError "${LINENO} 'mkfs.${RootType} ${RootPartition}'" 2
  esac
  echo "Mounting /root partition"	
  mount ${RootPartition} ${MOUNTPOINT} 2> error.log # eg: mount /dev/sda1 /mnt
  CheckForError "${LINENO} 'mount ${RootPartition} ${MOUNTPOINT}'" 2
  # Swap
  if [ ${SwapPartition} ]
  then
    echo "Making /swap partition"
    mkswap ${SwapPartition} 2> error.log # eg: mkswap /dev/sda2
    CheckForError "${LINENO} 'mkswap ${SwapPartition}'" 2
    echo "Activating /swap"
    swapon ${SwapPartition} 2> error.log # eg: swapon /dev/sda2
    CheckForError "${LINENO} 'swapon ${SwapPartition}'" 2
  elif [ ${SwapFile} ]; then
    fallocate -l ${SwapFile} /swapfile
    chmod 600 /swapfile
    mkswap /swapfile 2> error.log
    CheckForError "${LINENO} 'mkswap /swapfile'" 2
    swapon /swapfile 2> error.log
    CheckForError "${LINENO} 'swapon /swapfile'" 2
    echo "/swapfile none swap defaults 0 0" >> ${MOUNTPOINT}/etc/fstab
  fi
  echo "Mounting additional partitions"
  Counter=0
  Elements=${#AddPartList[@]}
 	# Repeat $Elements times getting data from the three arrays
  while [ $Counter -lt $Elements ]
  do
    mkdir -p ${MOUNTPOINT}${AddPartLabel[$Counter]} 2> error.log	# eg: mkdir -p /mnt/home
    CheckForError "${LINENO}" 0 # Non-critical, to allow for possible existing directory !!
    if [ ${AddPartType[$Counter]} != "Skip" ]
    then
      mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]} 2> error.log # eg: mkfs.ext4 /dev/sda3
      CheckForError "${LINENO} 'mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]}'" 2
    fi
    mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]} 2> error.log	# eg: mount /dev/sda3 /mnt/home
    CheckForError "${LINENO} 'mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]}'" 2
		Counter=$((Counter+1))
	done
}

TestExistingDM() {
  # Test for existing display manager and disable if necessary
  arch-chroot ${MOUNTPOINT} systemctl list-unit-files | grep dm.service > mnt/etc/output.log
  DMLine=`cat ${MOUNTPOINT}/etc/output.log`
  # Start a local counter to check for multiple entries
  local Counter=1
  case ${DMLine} in
    "") echo "No previous DM discovered"
    ;;
    *) local Continue="Y"
      while [ ${Continue} = "Y" ]
      do
        ExDM=`echo $DMLine  | cut -f ${Counter} -d ' '` # First of pair is DM
        if [ -z ${ExDM} ]; then
          Continue="N" # Quit if no further entries
          break
        fi
        Counter=$((Counter+1))
        ExDMStatus=`echo $DMLine  | cut -f ${Counter} -d ' '` # Second is status
        case ${ExDMStatus} in
          "enabled") arch_chroot "systemctl disable ${ExDM}" >/dev/null
          ;;
          *) echo "${ExDM} already disabled"
        esac
        Counter=$((Counter+1))
      done
  esac
}

# ----------------
#	End of Functions
# ----------------
