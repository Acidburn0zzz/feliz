#!/bin/bash

# Achoo! Arch Linux Installation Script 2015/07/16
# achoofuncs - Functions called by the main Achoo! script
# -----------------------------------------------------------
# This script and the achoovariables script must be present in the same
# directory when running the main Achoo! script
# -----------------------------------------------------------

# Developed by Elizabeth Mills, incorporating some code adapted from the
# Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.

# The Achoo! script is still in development, and may contain bugs.
# It was originally written for my own use, but it is shared in the spirit of
# the community, subject to the conditions set out in the GNU GENERAL LICENSE.
# Its purpose is to speed up installation of Arch Linux, plus a desktop
# environment and a greeter, with minimum user intervention.

# Users - You must plan your partition scheme and take care when entering
# your details, or loss of data could occur.

# -------------------------
# Functions           Line
# -------------------------
# Input and output     34
# Error-checking       77
# Mirrorlist           94
# Partitioning         125
# User & Location      436
# Desktop Environment  618
# Running              704
# ------------------------

# ----------------
# Input and output 
# ----------------

contains_element() { # (from AUI scripts)
# check if an element exists in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    print_line
    echo 
    read -t 2 -p "Invalid option. Try another one."
}

print_heading() {
	clear
    printf "                 # - The Achoo! Arch Linux Installation Script - # \n"
    print_title "    https://github.com/angeltoast/achoo   ~   https://wiki.archlinux.org/"
}

print_line() { # (from AUI scripts)
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() { # (from AUI scripts)
    print_line
    echo -e " ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() { # (from AUI scripts)
    # Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 10 )) | sed 's/^/\t/'
}

read_timed() {
  echo $1
  read -t 2 -p ""
}

# --------------
# Error-checking
# --------------

CheckForError() {
# Check for stderr, display it, then exit script
	if [[ $? -gt 0 ]]; then
    clear
		echo "Error reported at Line: $1"
    cat error.log
    echo "The script cannot continue"
    read -n1 -p "Please press any key: "
    echo ""
		exit
	fi
}

# -----------------------
# Mirrorlist
# -----------------------

LocalMirrorList() {
# Generate and save a shortened mirrorlist of only the mirrors defined
# in the CountryCode variable. Adapted from Lution AIS
	echo "Generating local mirrorlist"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist) 2> error.log
	CheckForError "${LINENO}"
	
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL} 2> error.log
	CheckForError "${LINENO}"
	
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp} 2> error.log
	CheckForError "${LINENO}"
	
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig 2> error.log
	CheckForError "${LINENO}"
	
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist 2> error.log
	CheckForError "${LINENO} 'saving mirrorlist'"  
	chmod +r /etc/pacman.d/mirrorlist 2> error.log
	CheckForError "${LINENO} 'saving mirrorlist'"
}

# ------------
# Partitioning
# ------------

ManagePartitions() {
# Check and show partitions ... call cfdisk
	# First test for existing partitions
	print_heading
	ShowPartitions=""
	PARTITIONS=""
	ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	# Count the partitions
  for i in ${ShowPartitions[@]}; do
    PARTITIONS="${PARTITIONS} ${i} -"
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
  done	
	# If no partitions exist, offer cfdisk to create (or exit)
	if [[ $NUMBER_PARTITIONS -eq 0 ]]; then
		print_heading
    echo ""
    echo "There are no partitions on the device. 'cfdisk' is available for you to"
    echo "create a partition table now if you wish."
    echo ""
    echo "Please note:"
    echo "  At least one partition, for the / (root) directory, must be created."
    echo "  Achoo! does not, as yet, support the UEFI/GPT partition table."
    echo "  If you are uncertain about partitioning, you should read the Arch Wiki."
    echo "  If you choose not to use 'cfdisk' now, the script will terminate, to"
    echo "     allow you to partition in some other way."
    echo ""
    read -p "Would you like to open cfdisk now? [Y/n]: " Response
    case $Response in
		  "y"|"Y"|"") cfdisk 2> error.log
      	CheckForError "${LINENO} 'cfdisk'"
			;;
		*) exit
		esac
 	else
    # Alternatively, offer cfdisk to edit existing partitions
		echo "Here is a list of available partitions on all connected devices ..."
		lsblk
		echo ""
		read -p "Would you like to open cfdisk to manage those partitions now? [Y/n]: " Response
		case $Response in
		  "y"|"Y"|"") cfdisk 2> error.log
            	CheckForError "${LINENO} 'cfdisk'"
			;;
      *) echo ""
		esac
	fi
  # After cfdisk, build new list of partitions
  PartitionList=" "
  ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
  for Part in ${ShowPartitions}
  do
    PartitionList="$PartitionList $Part"	# Add each partition
  done
}

select_filesystem() {
# Adapted from Lution
# Allows user-selection of filesystem by entering a number
# Returns enhanced selection via FILESYSTEM variable
	local Counter=0
	PS3="$prompt1"
	TypeList="Skip ext2 ext3 ext4 btrfs"	
	echo "Now select the file system for ${Partition}"
	select type in ${TypeList}
	do
    for i in ${TypeList}
		do
		local Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				PartitionType=$i
			fi
		done
		break
  done
}

AllocateRoot() {
# Display partitions for user-selection	
	# Uses list of all available partitions in PartitionList created in ManagePartitions
	print_heading
	Remaining=""
	local Counter=0
  Partition=""
	PartitionType=""
	PS3="$prompt1"
	echo "Here are the available partitions."
	echo "Select the one for root:" 
	select partition in ${PartitionList}
	do
    Reply=$REPLY
    for i in ${PartitionList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
				Partition="/dev/$i"
				echo "Root partition will be $Partition"
				RootPartition="${Partition}"
				select_filesystem
				if [ -z ${PartitionType} ]
				then
					RootType="ext4"
				else
          RootType="${PartitionType}"
        fi
			else
				Remaining="$Remaining $i"	# Add next available partition
			fi
		done
    PartitionList=$Remaining			# Replace original PartitionList with remaining options
		break
  done
}

AllocateSwap() {
  print_heading
  if [ -n ${#PartitionList[@]} ] # If there are remaining partitions from AllocateRoot ...
  then
    echo -e "Select the partition for /swap from the ones that remain."
    Remaining=""
    local Counter=0
    PS3="$prompt1"
    SwapPartition=""
    PartitionList="$PartitionList Skip"
    echo -e "If you select the 'Skip' option, no swap will be allocated:\n"
    select partition in ${PartitionList}
    do
    Reply=$REPLY
      for i in ${PartitionList}
      do
      Counter=$((Counter+1))
        if [ $Counter -eq $Reply ]
        then
          if [ $i = Skip ]; then
            SwapPartition=""
          else
            SwapPartition="/dev/$i"
          fi          
        else
          if [ $i != Skip ]; then
            Remaining="$Remaining $i"	# Add next available partition
          fi
        fi
      done
      break
    done
    if [ $SwapPartition ]; then
        read -t 2 -p "$SwapPartition will be used for swap."
    else
        read -t 2 -p "No swap partition will be allocated."
    fi
    PartitionList=$Remaining		# Replace original PartitionList with remaining options
  fi
}

ExtraPartitions() {
# If partitions on the device remain unselected
PartCounter=0
Elements=${#PartitionList[@]}
while [ $PartCounter -le $Elements ] # Display a list (including a 'Skip' option) 
do
	print_heading
	Remaining=""
	PS3="$prompt1"
  PartitionList="$PartitionList Skip"
	echo "The following partitions remain unallocated."
	echo "If you wish to use one, select it from the list."
  echo -e "Or choose 'Skip' to exit. \n"
	select partition in ${PartitionList} # User select an item from the list
	do
		Selected=$REPLY
		for Part in ${PartitionList} # Iterate through the list
		do
      Partition=""
      PartitionType=""
      PartCounter=$((PartCounter+1))
			if [ $PartCounter -eq $Selected ]
			then
        Item=$Part  # Selected item
        if [ $Item = Skip ]; then   # If item is 'Skip'
          #Counter=$Elements
          break     # Finish
        else                        # If item is not 'Skip'
        	Partition="/dev/$Item"
          MakePartition # Call MakePartition to complete details
        fi
      else                          # If $Counter is not equal to $Selected
        if [ $Part != Skip ]; then   # (and not 'Skip')
          Remaining="$Remaining $Part" # Add unused partition to temp list
        fi
			fi
    done
    if [ $Part = Skip ] || [ -z ${Remaining} ]; then  # If skip or there are no more to allocate
      break
    fi
  done
  if [ $Item = Skip ] || [ -z ${Remaining} ]; then
    break
  fi                     
  PartCounter=0
  PartitionList=$Remaining	# Replace original PartitionList with temp list
  Elements=${#PartitionList[@]}
done
# Ensure that if AddPartList (the defining array) is empty, all others are too
if [ -z ${#AddPartList[@]} ]
then
  AddPartList=""
  AddPartLabel=""
  AddPartType=""
fi
}

MakePartition() {
    # 1) When selected, first save to AddPartList (eg: /dev/sda5)
		ExtraPartitions=${#AddPartList[@]}
		AddPartList[$ExtraPartitions]="${Partition}"
    # 2) Then get a label for selected partition (eg: /home)
		LoopRepeat="Y"
		while [ ${LoopRepeat} = "Y" ]
		do
			echo "Enter a label for ${Partition} ... eg: '/home' ... "
      read -p "(you must include the '/'): " Response
			# Check that entry includes '/'
			CheckInput=(`echo $Response | cut -c1`)
			case ${CheckInput} in
        "") echo "You must enter a valid name"
						PartLabel=""
           ;;
				*) if [ ${CheckInput} != "/" ]
					then
						PartLabel="/${Response}"
					else
						PartLabel="${Response}"
					fi
      esac
      # Check that the label has not already been used
			LabelCounter=0
			if [ -z ${AddPartLabel} ]
			then
				LoopRepeat="N"
			else
				# Go through AddPartLabel checking each item against PartLabel
				for Label in ${AddPartLabel}
				do 
					LabelCounter=$((LabelCounter+1))
					if [ $Label = $PartLabel ] 
					then
						read -t 4 -p "Label ${PartLabel} has already been used. Please use a different label."
					else
						LoopRepeat="N"
						break
					fi
				done 
			fi 
			if [ ${LoopRepeat} = "N" ]  
			then
				break
			fi 
		done 
		# Add it to AddPartLabel list
		AddPartLabel[$ExtraPartitions]="${PartLabel}"
		# Set format type for the selected partition
		select_filesystem
    if [ -z ${PartitionType} ]
		then
			PartitionType="Skip"
		fi
		# Add it to AddPartType list
		AddPartType[$ExtraPartitions]="${PartitionType}"

}

# User to choose device for grub installation
SetGrubDevice() {
  # Store available devices in a list	
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd') Skip";
	# Display available devices and select one for Grub
	print_heading
  GrubDevice=""
	Counter=0
	PS3="$prompt1"
	print_info "Select the device where Grub is to be installed. Note that, if you"
  print_info "select the 'Skip' option, Grub will not be installed, and you will"
  print_info "have to make alternative arrangements for booting your system."
	select partition in ${DevicesList}
	do
  Reply=$REPLY
    for i in ${DevicesList}
		do
    Item=$i
  	Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
        if [ $Item = Skip ]; then
        GrubDevice=""
        else
        GrubDevice=$Item
        fi
      break
    	fi
 		done
    break
  done
}

# ------------------------------
# Locations, Names and Passwords
# ------------------------------

getkeymap() {
# New routine to enable user to input two-letter country-code to find keyboard
print_heading
DoDoDo=1
echo "Now we will try to find your keyboard from a list of all known"
echo "layouts. If you know your keyboard code, enter it now. Alternatively, "
SearchPrompt="enter the two-letter code for your country (eg: uk or us): "
while [ $DoDoDo -eq 1 ]
do
  PS3="$prompt1"
  read -p "$SearchPrompt" search_term
  echo ""
  SEARCHTERM="${search_term,,}"
  KeyboardList=(`localectl list-keymaps | grep ${SEARCHTERM} | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'` );
  Counter=${#KeyboardList[@]}
  Counter=$((Counter+1))
  KeyboardList[$Counter]='Try_Again'
  echo ""
  echo "Choose your keyboard, or 'Try_Again': "
  echo""
  select KEYMAP in "${KeyboardList[@]}"; do
    if contains_element "$KEYMAP" "${KeyboardList[@]}"
    then
      if [ $KEYMAP = "Try_Again" ]
      then
        print_heading
        echo "Try a different two-letter code: "
        break
      else
        Countrykbd=$KEYMAP
        DoDoDo=0
        break
      fi
    else
      invalid_option
    fi
  done
done
}

setlocale() {
# New routine to enable user to input two-letter country-code to find locale
print_heading
PS3="$prompt1"
DoDoDo=1
SearchPrompt="Enter the two-letter code for your country or language (eg: GB or en): "
echo "Next we will try to find your locale"
while [ $DoDoDo -eq 1 ]
do
  read -p "$SearchPrompt" search_term
  echo ""
  SEARCHTERM=${search_term}
  LocaleList=(`cat /etc/locale.gen | grep ${SEARCHTERM}....UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
 Counter=${#LocaleList[@]}
  if [ $Counter -eq 0 ]
  then 
    SEARCHTERM="${search_term^^}"
    LocaleList=(`cat /etc/locale.gen | grep ${SEARCHTERM}.UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    Counter=${#LocaleList[@]}
  fi
  Counter=$((Counter+1))
  LocaleList[$Counter]='Try_Again'
  echo ""
  echo "Choose your locale, or 'Try_Again': "
  echo""
  select LOCALE in "${LocaleList[@]}"; do
    if contains_element "$LOCALE" "${LocaleList[@]}"
    then
      if [ $LOCALE = "Try_Again" ]
      then
        print_heading
        echo "Try a different two-letter code (try UPPER CASE): "
        break
      else
        CountryLocale="${LOCALE}.UTF-8"
        CountryCode=(`echo $LOCALE | cut -c4-6`)
        DoDoDo=0
        break
      fi
    else
      invalid_option
    fi
  done
done

}

settimezone() {
# Variables "ZONE" and "SUBZONE" - Defaults = "Europe/London"
print_heading
print_info "Now we have to set up the best mirrors for downloading your system"
print_info "This will also be used for setting the clock during installation"
print_info "Choose the World Zone of your location from the following list"
# Set Zone and Sub-Zone from lists (from AUI)
  local _zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
  PS3="$prompt1"
  echo "Select zone:"
  select ZONE in "${_zones[@]}"
  do
    if contains_element "$ZONE" "${_zones[@]}"; then
      local _subzones=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
      print_heading
      PS3="$prompt1"
      echo "Now select your local city or Sub-Zone:"
      select SUBZONE in "${_subzones[@]}"; do
        if contains_element "$SUBZONE" "${_subzones[@]}"; then
          break
        else
          invalid_option
        fi
      done
      break
    else
      invalid_option
    fi
  done
}

UserAndRoot() {
# Accept user input of hostname, username, user password and root password
	while [ $Repeat ]
	do
		# Hostname
		Entered="ArchLinux"
		print_heading
		print_info "A hostname is needed. This will be a unique name to identify"
		print_info "your device on a network. If you do not enter one, the default"
		print_info "hostname of 'ArchLinux' will be used."
		read -p "Enter a hostname for your computer : " Entered
		case $Entered in
			"") Entered=$HostName
			;;
			*) HostName=${Entered}
		esac
		echo "Hostname set to: $HostName"
		# Username
		print_heading
		Entered="Archie"
		print_info "Next we have to deal with names and passwords."
		print_line
		print_info "If you don't create a username here, a default user called"
    print_info "'archie' will be set up"
		read -p "Enter a username (must be all lower case): " Entered
		case $Entered in
			"") Entered=$UserName
			;;
			*) UserName=${Entered}
		esac
		echo "Username set to: $UserName"
  	# User password
		print_heading
		Entered="Linux"
		print_info "Passwords should be a mixture of upper- and lower-case letters"
		print_info "plus numbers and special characters. If you do not enter"
		print_info "a user password, the default of 'Linux' will be used."
		read -p "Enter a password for $UserName: " Entered
		case $Entered in
			"") Entered=$UserPassword
			;;
			*) UserPassword=${Entered}
		esac
		echo "User password set to: $UserPassword}"
		# Root password
		print_heading
		Entered="Root"
		print_info "Now set a password for root. If you do not enter one, a default"
    print_info "password of 'Root' will be used."
		read -p "Enter a password for root: " Entered
		case $Entered in
			"") Entered=$RootPassword
			;;
			*) RootPassword=${Entered}
		esac
		echo "Root password set to: $RootPassword"
	break
	done
}

# -------------------
# Desktop Environment
# -------------------

ChooseDE() {
	Counter=0
	PS3="$prompt1"
	DEList="LXDE LXQt Mate Xfce Skip"
  print_heading
  echo "This installer offers only the 'lightweight' Desktop Environments."
  echo "Mate and Xfce include many of the essential desktop tools, whereas LXDE and LXQt are basic desktops onto which you can add your choice of tools."
  echo "Note that LXDE and LXQt include the Openbox window manager - useful for building your own desktop."
  echo "Or you can choose to skip this option and install something else manually later."
  echo ""
	echo "Choose your Desktop Environment"
	select type in ${DEList}
	do
  Reply=$REPLY
  SelectedDE=type
    for i in ${DEList}
    do
      Item=$i
      Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
      DesktopEnvironment=$Item
      case $Item in
        "LXDE") DisplayManager=""
              Greeter=""
          ;;
        "LXQt") DisplayManager="sddm"
              Greeter=""
          ;;
        "Mate") DMList="LightDM LXDM Skip"
              ChooseDM
          ;;
        "Xfce") DMList="LightDM LXDM Skip"
              ChooseDM
          ;;
        *) DesktopEnvironment=""
            DisplayManager=""
              Greeter=""	
 			esac
      break
			fi
		done
		break
  done
}

ChooseDM() {
  # Choice of Display Manager from list passed via DMList
  Counter=0
  PS3="$prompt1"
  print_heading
  print_info "Choose one of the following Display Managers for "$Item
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
  echo "Choose your Display Manager"
  select type in ${DMList}
  do
  Reply=$REPLY
    for item in ${DMList}
    do
      Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        SelectedDM=$item
        case $SelectedDM in
          "LightDM") DisplayManager="lightdm"
                Greeter="lightdm-gtk-greeter"	
              ;;
          "LXDM") DisplayManager="lxdm"
                Greeter=""
              ;;
          *) DisplayManager=""
                Greeter=""
        esac	
        break
      fi
    done
		break
  done
}

# -------
# Running
# -------

arch_chroot() {
# Taken directly from Lution AIS
# Function chroots to MOUNTPOINT (/mnt) for parameter passed from caller
  arch-chroot ${MOUNTPOINT} /bin/bash -c "${1}" 2> error.log
  CheckForError "${LINENO} 'arch-chroot ${MOUNTPOINT} ${1}'"
}  

# Unmount partitions (from Lution/AUI - Nice code)
# 1) Gets a list of all mounted partitions into MOUNTED
# 2) Sets swap off for all devices marked as 'swap' in /etc/fstab
# 3) Unmounts each mounted device in turn from MOUNTED
umount_partitions(){
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a 2> error.log
  CheckForError "${LINENO} 'swapoff'"
  for i in ${MOUNTED[@]}; do
    umount $i >/dev/null 2> error.log
    CheckForError "${LINENO} 'umount $i >/dev/null'"
  done

}

MountPartitions() {
  # Root
  case $RootType in
    "") echo "Not formatting root partition"
    ;;
    "Skip") echo "Not formatting root partition"
    ;;
    *) echo "Formatting /root partition"
    mkfs.${RootType} ${RootPartition} 2> error.log # eg: mkfs.ext4 /dev/sda1
    CheckForError "${LINENO} 'mkfs.${RootType} ${RootPartition}'"
  esac
  echo "Mounting /root partition"	
  mount ${RootPartition} ${MOUNTPOINT} 2> error.log # eg: mount /dev/sda1 /mnt
  CheckForError "${LINENO} 'mount ${RootPartition} ${MOUNTPOINT}'"
  # Swap
  if [ ${SwapPartition} ]
  then
    echo "Making /swap partition"
    mkswap ${SwapPartition} 2> error.log # eg: mkswap /dev/sda2
    CheckForError "${LINENO} 'mkswap ${SwapPartition}'"
    echo "Activating /swap"
    swapon ${SwapPartition} 2> error.log # eg: swapon /dev/sda2
    CheckForError "${LINENO} 'swapon ${SwapPartition}'"
  fi
  echo "Mounting additional partitions"
  Counter=0
  Elements=${#AddPartList[@]}
 	# Repeat $Elements times getting data from the three arrays
  while [ $Counter -lt $Elements ]
  do
    mkdir -p ${MOUNTPOINT}${AddPartLabel[$Counter]} 2> error.log	# eg: mkdir -p /mnt/home
    # CheckForError "${LINENO}" !! Error-checking turned off here to allow for possible existing directory !!
    if [ ${AddPartType[$Counter]} != "Skip" ]
    then
      mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]} 2> error.log # eg: mkfs.ext4 /dev/sda3
      CheckForError "${LINENO} 'mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]}'"
    fi
    mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]} 2> error.log	# eg: mount /dev/sda3 /mnt/home
    CheckForError "${LINENO} 'mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]}'"
		Counter=$((Counter+1))
	done
}

# ----------------
#	End of Functions
# ----------------
