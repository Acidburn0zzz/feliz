#!/bin/bash
#
# Achoo! Arch Linux Installation Script Version 0.1
# AchooFuncs - Functions called by the main Achoo! script
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Achoo! Development version 2015/06/16
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Include this script and the AchooVariables script when compiling the
# main Achoo! script into an iso for code testing, and when uploading
# this major rewrite to Git and Github
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Developed by Elizabeth Mills, incorporating some code adapted from
# the lution-ais script by Carl Duff for Evo/Lution Linux and the
# AUI scripts by HelmuthDU. I cannot overstate my debt to these two
# men for their contributions to my understanding of the process.
#
# The Achoo! script is in its early stages of development. As such,
# it may be unstable and will contain bugs. It was originally written
# for my own use, but it is shared in the spirit of of the community,
# subject to the conditions set out in the GNU GENERAL LICENSE 
#
# Its purpose is to speed up installation of Arch Linux, plus a desktop
# environment and a greeter, with minimum user intervention. Variables
# and functions are stored in separate scripts for easy access.
#
# Users - You must plan your partition scheme and take care when entering
# your details, or loss of data could occur.

# ~~~~~~~~~~~~~~~~~~~~~~~~~
#
#	 	Functions
#		---------
#	Input and output
#	Error-checking
#	Set location variables
#	System checks
#	Mirrorlist
#	System & partitioning
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~
# Input and output 
# ~~~~~~~~~~~~~~~~~

# check if an element exist in a string
contains_element() { # (from AUI scripts)
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    print_line
    echo "Invalid option. Try another one."
    read -p "$OutPrompt" Response
}

print_heading() { # (from AUI scripts)
	clear
    printf "                 # - The Achoo! Arch Linux Installation Script - # \n"
    print_title "    https://github.com/Angeltoast/Achoo   ~   https://wiki.archlinux.org/"
}

print_line() { # (from AUI scripts)
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() { # (from AUI scripts)
    print_line
    echo -e " ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() { # (from AUI scripts)
    # Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
}

# ~~~~~~~~~~~~~~~~~
#	Error-checking
# ~~~~~~~~~~~~~~~~~

# Check for error, display it and exit
CheckForError() {
	if [[ $? -gt 0 ]]; then
		echo "An error occurred at $1"
		read -r Response
		exit
	else
		echo "Preparing next step ..."
	fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 	Locations, Names and Passwords
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Locations display loop
SetLocation(){
	InPrompt="Do you wish to change any of these? [y/n]: "
	while [ $Repeat ]
	do
	print_heading
	print_info "The best way to install Arch Linux is to follow the Wiki."
	print_info "But sometimes you just want a quick installation, and that's where Achoo! comes in."
	print_info "First we need to gather some important information to ensure it meets your needs."
	print_info "Beginning with the settings for your location ..."
	print_line
	print_info "The country code is set to:  $CountryCode"	# Country code for mirrorlist
	print_info "The keyboard code is set to: $Countrykbd"	# Country for keyboard
	print_info "The time zone is set to: $ZONE/$SUBZONE"	# For time
	print_info "The locale is set to: $CountryLocale"		# Locale
	echo ""
	read -p "$InPrompt" Response
	case $Response in
		"y") EditLocales
		;;
		"Y") EditLocales
		;;
		*) break
	esac
	break
	done
}

EditLocales(){
	InPrompt="Please press any key"

	# (1) Variable ="Countrykbd" - Default = "uk" - Used for keyboard code
	print_heading
	echo "The keyboard code is currently: '$Countrykbd'"
	read -p "A list will be displayed for you to choose - $InPrompt" Response
	getkeymap
	read -p "The keyboard is now set to: '$Countrykbd'. $InPrompt"
	# End of keyboard code
				
	# (2) Variables = "ZONE" and "SUBZONE" - Defaults = "Europe/London"	
	print_heading
	echo "The zone settings are currently: '$ZONE/$SUBZONE'"
	read -p "A list will be displayed for you to choose - $InPrompt" Response
	settimezone
	read -p "Zone and Subzone are now set to: '$ZONE/$SUBZONE'. $InPrompt"
	# End of ZONE/SUBZONE code
		
	# (3) Variable = "CountryLocale" - Default = "en_GB.UTF-8"
	# Also sets CountryCode
	print_heading
	echo "The locale setting is currently: '$CountryLocale'"
	read -p "A list will be displayed for you to choose - $InPrompt" Response
	setlocale
	read -p "Locale is now set to: '$CountryLocale'. $InPrompt"	
	Repeat=0
	  
}

# Build keymap (from AUI)
getkeymap() {
  local _keymaps=(`localectl list-keymaps`)
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select KEYMAP in "${_keymaps[@]}"; do
      if contains_element "$KEYMAP" "${_keymaps[@]}"; then
		Countrykbd=$KEYMAP
        break
      else
        invalid_option
      fi
    done
}

# Generate list of locales  (from AUI)
setlocale() {
    local _locale_list=(`cat /etc/locale.gen | grep UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    PS3="$prompt1"
    echo "Select locale:"
    select LOCALE in "${_locale_list[@]}"; do
      if contains_element "$LOCALE" "${_locale_list[@]}"; then
        LOCALE_UTF8="${LOCALE}.UTF-8"
        CountryLocale=${LOCALE}
        CountryCode=(`echo $LOCALE | cut -c4-6`)
        break
      else
        invalid_option
      fi
    done
}

# Set Zone and Sub-Zone from lists (from AUI)
settimezone() {
    local _zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
    PS3="$prompt1"
    echo "Select zone:"
    select ZONE in "${_zones[@]}"; do
      if contains_element "$ZONE" "${_zones[@]}"; then
        local _subzones=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
        print_heading
        PS3="$prompt1"
        echo "Select subzone:"
        select SUBZONE in "${_subzones[@]}"; do
          if contains_element "$SUBZONE" "${_subzones[@]}"; then
            break
          else
            invalid_option
          fi
        done
        break
      else
        invalid_option
      fi
    done
}

# Accept user input of hostname, username, user password and root password
UserAndRoot() {
	while [ $Repeat ]
	do
		# Hostname
		Entered="ArchLinux"
		print_heading
		print_info "A hostname is needed. This will be a unique name created to identify your device on a network."
		print_info "If you do not enter one, the default hostname of 'ArchLinux' will be used."
		read -p "Enter a hostname for your computer (for example: archlinux): " Entered
		case $Entered in
			"") Entered=$HostName
			;;
			*) HostName=${Entered}
		esac
		echo "Hostname set to: $HostName}"
		
		# Username
		print_heading
		Entered="Archie"
		print_info "Next we have to deal with names and passwords."
		print_line
		print_info "If you don't create a username here, a default user called 'archie' will be set up, with a password of 'Linux'"
		read -p "Enter a username (must be all lower case): " Entered
		
		case $Entered in
			"") Entered=$UserName
			;;
			*) UserName=${Entered}
		esac
		echo "Username set to: $UserName"

		# User password
		print_heading
		Entered="Linux"
		print_info "Passwords should be a mixture of upper- and lower-case letters, numbers and special characters."
		print_info "If you do not enter a password, the default of 'Linux' will be used."
		read -p "Enter a password for $UserName: " Entered
		case $Entered in
			"") Entered=$UserPassword
			;;
			*) UserPassword=${Entered}
		esac
		echo "User password set to: $UserPassword}"
		
		# Root password
		print_heading
		Entered="Root"
		print_info "And finally, a password for root. If you do not enter one, the default of 'Root' will be used."
		read -p "Enter a password for root: " Entered
		case $Entered in
			"") Entered=$RootPassword
			;;
			*) RootPassword=${Entered}
		esac
		echo "Root password set to: $RootPassword}"
	break
	done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     System and Partitioning
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Generate and save a shortened mirrorlist of only the mirrors defined
# in the CountryCode variable. Adapted from Lution AIS
LocalMirrorList() {

	echo "Generating local mirrorlist"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist)
	CheckForError "Line ${LINENO}"
	
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL} 2>/tmp/.errlog
	CheckForError "Line ${LINENO}"
	
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp}
	CheckForError "Line ${LINENO}"
	
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
	CheckForError "Line ${LINENO}"
	
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist
	chmod +r /etc/pacman.d/mirrorlist
	CheckForError "Line ${LINENO}"
	
}

# Taken directly from Lution AIS (adapted by Carl from helmutdu's AIS)
# Function chroots to MOUNTPOINT (/mnt) for parameter passed from caller
arch_chroot() {
	
    arch-chroot ${MOUNTPOINT} /bin/bash -c "${1}"
    
}  

# Check and show partitions.
ManagePartitions() {
	
	# First test for existing partitions
	print_heading
	ShowPartitions=""
	PARTITIONS=""
	ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	
	# Count the partitions
    for i in ${ShowPartitions[@]}; do
       PARTITIONS="${PARTITIONS} ${i} -"
       NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done	

	# If no partitions exist, offer cfdisk to create (or exit)
	# Alternatively, offer cfdisk to edit
	# NUMBER_PARTITIONS="0"			# To test situation of zero partitions
	if [[ $NUMBER_PARTITIONS -eq 0 ]] ; then
		print_heading
        echo "There are no partitions on the device, and we cannot continue without partitions on which to install. However, 'cfdisk' is available for you to create a partition table if you wish."
		echo "If you are uncertain about partitioning, you should read the Wiki (address at the top)"
        echo "If you choose not to use 'cfdisk', the script will terminate."
        read -p "Would you like to open cfdisk now? [y/n]: " Response
        case $Response in
		"y" | "Y")  cfdisk
			echo "Response $Response ... cfdisk selected"
			;;	
		*) echo "Response $Response ... cfdisk not selected. Exiting installation!"
			exit
		esac
 	else
		echo "Before we can install the system, the device must be partitioned ready to receive it."
		echo "If you are uncertain about partitioning, you should read the Wiki (address at the top)"
		echo "Here is a list of available partitions on all connected devices ..."
		lsblk
		echo ""
		read -p "Would you like to open cfdisk to manage the partitions now? [y/n]: " Response
    
		case $Response in
		"y" | "Y")  cfdisk
			echo "Response $Response ... cfdisk selected"
			;;	
		*) echo "Response $Response ... cfdisk not selected"
		esac
	fi
}

# Display partitions for user-selection
AllocatePartitions() {
	
	# Store all available partitions in a list
	PartitionList=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	
	# Display available partitions in a vertical, numbered list
	# and select one for /root
	print_heading
	Remaining=""
	Counter=0
	PS3="$prompt1"
	echo -e "Select the partition for /root:\n"
	select partition in ${PartitionList}
	do
        for i in ${PartitionList}
		do
		Partition=""
		PartitionType=""
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				Partition="/dev/$i"
				echo "Root partition will be $Partition"
				RootPartition="${Partition}"
				select_filesystem
				if [ -z ${PartitionType} ]
				then
					RootType="ext4"
				fi
				RootType="${PartitionType}"
			else
				Remaining="$Remaining $i"	# Add next available partition
			fi
		PartitionList=$Remaining			# Replace original PartitionList with remaining options
		done
		break
    done

	# Display remaining partitions and select one for /swap
	echo ""
	Remaining=""
	Counter=0
	PS3="$prompt1"
	echo -e "Now select the partition for /swap from the ones that remain:\n"
	select partition in ${PartitionList}; do
        for i in ${PartitionList}
		do
		Counter=$((Counter+1))
		if [ $Counter -eq $REPLY ]
		then
			SwapPartition="/dev/$i"
			read -p "$SwapPartition selected as /swap. ${OutPrompt}" Response
		else
			Remaining="$Remaining $i"	# Add next available partition
		fi
		PartitionList=$Remaining		# Replace original PartitionList with remaining options
		done
	break
    done
	if [ -n ${PartitionList[1]} ]
	then
		ExtraPartitions
	fi
}

ExtraPartitions() {
	
Remaining=""
declare -a AddPartList		# Array to hold list of additional partitions by partition system name. eg: /dev/sda5
declare -a AddPartType		# Array to hold same partitions in same order by partition type. eg: ext2
declare -a AddPartLabel		# Array to hold same partitions in same order by given name. eg: /home
Counter=0
Elements=${#AddPartList[@]}]
while [ $Counter -lt $Elements ]
do
	print_heading
	echo "The following partitions are still available: ${PartitionList}"
	read -p "Do you wish to allocate any of these? [y/N]: " Response
	case $Response in
		"y") echo ""
		;;
		"Y") echo ""
		;;
		*) break
	esac
	Remaining=""

	PS3="$prompt1"
	echo -e "Select the partition to be allocated \n"
	select partition in ${PartitionList}
	do
        for i in ${PartitionList}
		do
		Partition=""
		PartitionType=""
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				Partition="/dev/$i"
			# 1) When selected, first save to AddPartList (eg: /dev/sda5)
				Elements=${#AddPartList[@]}
				AddPartList[$Elements]=" ${Partition} "
				
			# 2) Then get a label for selected partition (eg: /home)
			# {{{ Start the loop here
				LoopRepeat="Y"
				while [ ${LoopRepeat} = "Y" ]
				do
					read -p "Enter a label for ${Partition} ... eg: '/home' (you must include the '/'): " Response
					# Check that entry includes '/'
					CheckInput=(`echo $Response | cut -c1`)
					case ${CheckInput} in
						"") echo "You must enter a valid name"
							PartLabel=""
						;;
						*) if [ ${CheckInput} != "/" ]
							then
								PartLabel="/${Response}"
							else
								PartLabel="${Response}"
							fi
					esac
				#
				# Check that the label has not already been used
					LabelCounter=0
					if [ -z ${AddPartLabel} ]
					then
						LoopRepeat="N"
					else
						# Go through AddPartLabel checking each item against PartLabel
						for i in ${AddPartLabel}
						do
							LabelCounter=$((LabelCounter+1))
							echo $i
							if [ $PartLabel = $i ]
							then
								read -p "Label ${PartLabel} has already been used. Please use a different label." Response
							else
								LoopRepeat="N"
								break
							fi
						done
					fi
					if [ ${LoopRepeat} = "N" ]
					then
						break
					fi
				done
			# }}}
			# Add it to AddPartLabel list
				Elements=${#AddPartLabel[@]}
				AddPartLabel[$Elements]=" ${PartLabel} "
				
			# 3) Then get a partition type (eg: ext4)
				select_filesystem
				if [ -z ${PartitionType} ]
				then
					PartType="-"
				else
					PartType="${PartitionType}"
				fi
				echo "${PartLabel} ${Partition} is ${PartType}"
			# Add partition type to AddPartType (eg: ext2)
				Elements=${#AddPartType[@]}
				AddPartLabel[$Elements]=" ${PartType} "
				
			else
				Remaining="$Remaining $i"	# Add unused partition
			fi

		done
		break
    done
    PartitionList=$Remaining			# Replace original PartitionList with remaining options
done
}

# Adapted from Lution
# Allows user-selection of filesystem by entering a number
# Returns enhanced selection via FILESYSTEM variable
select_filesystem() {

	Counter=0
	PS3="$prompt1"
	TypeList="Skip ext2 ext3 ext4"	# Note: ext2 requires different 'make' tool
	echo "Now select the format type for ${Partition}"
	select type in ${TypeList}
	do
        for i in ${TypeList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				if [ "$i" = "Skip" ]
				then
					PartitionType=""
					echo "Partition ${Partition} will not be formatted"
				else
					PartitionType="$i"
					echo "Partition ${Partition} will be formatted to: $PartitionType"
				fi
			fi
		done
		break
    done

}

# User to choose device for grub installation
SetGrubDevice() {

	# Store available devices in a list	
    DEVICE=""
    DevicesList=$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd');
    
	# Display available devices and select one for Grub
	print_heading
	Counter=0
	PS3="$prompt1"
	echo -e "Select the device for Grub:\n"
	select partition in ${DevicesList}; do
        for i in ${DevicesList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				GrubDevice=$i
				echo "Grub will be installed on $GrubDevice"
			fi
		done
		break
    done
}

# Unmount partitions (from Lution/AUI - Nice code)
# 1) Gets a list of all mounted partitions into MOUNTED
# 2) Sets swap off for all devices marked as 'swap' in /etc/fstab
# 3) Unmounts each mounted device in turn from MOUNTED
umount_partitions(){
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  for i in ${MOUNTED[@]}; do
      umount $i >/dev/null 2>>/tmp/.errlog
  done
  CheckForError "Line ${LINENO}"
}

# ~~~~~~~~~~~~~~~~~~~~~~
#	 End of Functions
# ~~~~~~~~~~~~~~~~~~~~~~
