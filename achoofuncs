#!/bin/bash

# Achoo! Arch Linux Installation Script 2015/07/08
# achoofuncs - Functions called by the main Achoo! script
# -----------------------------------------------------------
# This script and the achoovariables script are necessary when
# running the main Achoo! script
# -----------------------------------------------------------

# Developed by Elizabeth Mills, incorporating some code adapted from the
# Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.
#
# The Achoo! script is still in development, and may contain bugs.
# It was originally written for my own use, but it is shared in the spirit of
# the community, subject to the conditions set out in the GNU GENERAL LICENSE.
#
# Its purpose is to speed up installation of Arch Linux, plus a desktop
# environment and a greeter, with minimum user intervention.
#
# Users - You must plan your partition scheme and take care when entering
# your details, or loss of data could occur.

# ----------------
# Functions layout
# ----------------
# Input and output
# Error-checking
# Set location variables
# Choose desktop environment
# Mirrorlist
# System & partitioning
# ---------------------

# ----------------
# Input and output 
# ----------------

contains_element() { # (from AUI scripts)
# check if an element exists in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    print_line
    echo "Invalid option. Try another one."
    read -p "$OutPrompt" Response
}

print_heading() {
	clear
    printf "                 # - The Achoo! Arch Linux Installation Script - # \n"
    print_title "    https://github.com/Angeltoast/Achoo   ~   https://wiki.archlinux.org/"
}

print_line() { # (from AUI scripts)
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() { # (from AUI scripts)
    print_line
    echo -e " ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() { # (from AUI scripts)
    # Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 10 )) | sed 's/^/\t/'
}

# --------------
# Error-checking
# --------------

CheckForError() {
# Check for error, display it, then exit program
	if [[ $? -gt 0 ]]; then
		echo "An error occurred at $1"
		read -r Response
		exit
	else
		echo "Preparing next step ..."
	fi
}

# ------------------------------
# Locations, Names and Passwords
# ------------------------------

SetLocation() {
# Locations display loop
	InPrompt="Do you wish to change any of these? [y/n]: "
	while [ $Repeat ]
	do
	print_heading
	print_info "The best way to install Arch Linux is to follow the Wiki."
	print_info "But sometimes you just want a quick installation, and that's where Achoo! comes in."
	print_info "First we need to gather some important information, beginning with the settings for your location ..."
	print_line
	print_info "The country code is set to:  $CountryCode" # For mirrorlist
	print_info "The keyboard code is set to: $Countrykbd" # For keyboard
	print_info "The time zone is set to: $ZONE/$SUBZONE" # For time
	print_info "The locale is set to: $CountryLocale" # Locale
	echo ""
	read -p "$InPrompt" Response
	case $Response in
		"y"|"Y") EditLocales
		;;
		*) echo ""
	esac
	break
	done
}

EditLocales() {
	# (1) Variable "Countrykbd" - Default = "uk" - Used for keyboard code
	print_heading
	echo "The keyboard code is currently: '$Countrykbd'"
	read -p "A list will be displayed for you to choose - $OutPrompt"
	getkeymap
	read -p "The keyboard is now set to: '$Countrykbd'. $OutPrompt"
	# End of keyboard code
	# (2) Variables "ZONE" and "SUBZONE" - Defaults = "Europe/London"	
	print_heading
	echo "The zone settings are currently: '$ZONE/$SUBZONE'"
	read -p "A list will be displayed for you to choose - $OutPrompt"
	settimezone
	read -p "Zone and Subzone are now set to: '$ZONE/$SUBZONE'. $OutPrompt"
	# End of ZONE/SUBZONE code
	# (3) Variable "CountryLocale" - Default = "en_GB.UTF-8"
	# Also sets CountryCode to "GB"
	print_heading
	echo "The locale setting is currently: '$CountryLocale'"
	read -p "A list will be displayed for you to choose - $OutPrompt"
	setlocale
	read -p "Locale is now set to: '$CountryLocale'. $OutPrompt"	
	Repeat=0
}

getkeymap() {
# Build keymap (from AUI)
  local _keymaps=(`localectl list-keymaps`)
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select KEYMAP in "${_keymaps[@]}"; do
      if contains_element "$KEYMAP" "${_keymaps[@]}"
      then
    		Countrykbd=$KEYMAP
        break
      else
        invalid_option
      fi
    done
}

setlocale() {
# Generate list of locales  (from AUI)
    local _locale_list=(`cat /etc/locale.gen | grep UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    PS3="$prompt1"
    echo "Select locale:"
    select LOCALE in "${_locale_list[@]}"; do
      if contains_element "$LOCALE" "${_locale_list[@]}"; then
        LOCALE_UTF8="${LOCALE}.UTF-8"
        CountryLocale=${LOCALE_UTF8}
        CountryCode=(`echo $LOCALE | cut -c4-6`)
        break
      else
        invalid_option
      fi
    done
}

settimezone() {
# Set Zone and Sub-Zone from lists (from AUI)
  local _zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
  PS3="$prompt1"
  echo "Select zone:"
  select ZONE in "${_zones[@]}"
  do
    if contains_element "$ZONE" "${_zones[@]}"; then
      local _subzones=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
      print_heading
      PS3="$prompt1"
      echo "Select subzone:"
      select SUBZONE in "${_subzones[@]}"; do
        if contains_element "$SUBZONE" "${_subzones[@]}"; then
          break
        else
          invalid_option
        fi
      done
      break
    else
      invalid_option
    fi
  done
}

UserAndRoot() {
# Accept user input of hostname, username, user password and root password
	while [ $Repeat ]
	do
		# Hostname
		Entered="ArchLinux"
		print_heading
		print_info "A hostname is needed. This will be a unique name created to identify your device on a network."
		print_info "If you do not enter one, the default hostname of 'ArchLinux' will be used."
		read -p "Enter a hostname for your computer (for example: archlinux): " Entered
		case $Entered in
			"") Entered=$HostName
			;;
			*) HostName=${Entered}
		esac
		echo "Hostname set to: $HostName"
		# Username
		print_heading
		Entered="Archie"
		print_info "Next we have to deal with names and passwords."
		print_line
		print_info "If you don't create a username here, a default user called 'archie' will be set up, with a password of 'Linux'"
		read -p "Enter a username (must be all lower case): " Entered
		case $Entered in
			"") Entered=$UserName
			;;
			*) UserName=${Entered}
		esac
		echo "Username set to: $UserName"
  	# User password
		print_heading
		Entered="Linux"
		print_info "Passwords should be a mixture of upper- and lower-case letters, numbers and special characters."
		print_info "If you do not enter a user password, the default of 'Linux' will be used."
		read -p "Enter a password for $UserName: " Entered
		case $Entered in
			"") Entered=$UserPassword
			;;
			*) UserPassword=${Entered}
		esac
		echo "User password set to: $UserPassword}"
		# Root password
		print_heading
		Entered="Root"
		print_info "Now set a password for root. If you do not enter one, the default of 'Root' will be used."
		read -p "Enter a password for root: " Entered
		case $Entered in
			"") Entered=$RootPassword
			;;
			*) RootPassword=${Entered}
		esac
		echo "Root password set to: $RootPassword"
	break
	done
}

ChooseDE() {  # This is new code with option of Xfce, Gnome or skip
	Counter=0
	PS3="$prompt1"
	DEList="Gnome Xfce Skip"
  print_heading
  print_info "This installer offers only Gnome or Xfce Desktop Environments."
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
	echo "Choose your Desktop Environment"
	select type in ${DEList}
	do
  Reply=$REPLY
    for i in ${DEList}
    do
      Item=$i
      Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
      case $Item in
        "Gnome") DesktopEnvironment="gnome gnome-extra"
              DisplayManager="gdm"
              Greeter=""
          ;;
        "Xfce") DesktopEnvironment="xfce4 xfce4-goodies polkit-gnome"
              DMList="LightDM LXDM Skip"
              ChooseDM
              case $SelectedDM in
                "LightDM") DisplayManager="lightdm"
                  Greeter="lightdm-gtk-greeter"	
                  ;;
                "LXDM") DisplayManager="lxdm"
                  Greeter=""
                  ;;
                *) DisplayManager=""
                  Greeter=""
              esac	
          ;;
        *) DesktopEnvironment=""
            DisplayManager=""
              Greeter=""	
 			esac
      break
			fi
		done
		break
  done
}

ChooseDM() {
  # Choice of Display Manager from list passed via DMList
  Counter=0
  PS3="$prompt1"
  print_heading
  print_info "Choose one of the following Display Managers for $SelectedDE"
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
  echo "Choose your Display Manager"
  select type in ${DMList}
  do
  Reply=$REPLY
    for item in ${DMList}
    do
      Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        SelectedDM=$item
        break
      fi
    done
		break
  done
}

# -----------------------
# System and Partitioning
# -----------------------

LocalMirrorList() {
# Generate and save a shortened mirrorlist of only the mirrors defined
# in the CountryCode variable. Adapted from Lution AIS
	echo "Generating local mirrorlist"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist)
	CheckForError "Line ${LINENO}"
	
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL}
	CheckForError "Line ${LINENO}"
	
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp}
	CheckForError "Line ${LINENO}"
	
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
	CheckForError "Line ${LINENO}"
	
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist
	chmod +r /etc/pacman.d/mirrorlist
	CheckForError "Line ${LINENO}"
}

arch_chroot() {
# Taken directly from Lution AIS
# Function chroots to MOUNTPOINT (/mnt) for parameter passed from caller
    arch-chroot ${MOUNTPOINT} /bin/bash -c "${1}"
}  

ManagePartitions() {
# Check and show partitions.	
	# First test for existing partitions
	print_heading
	ShowPartitions=""
	PARTITIONS=""
	ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	# Count the partitions
  for i in ${ShowPartitions[@]}; do
    PARTITIONS="${PARTITIONS} ${i} -"
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
  done	
	# If no partitions exist, offer cfdisk to create (or exit)
	if [[ $NUMBER_PARTITIONS -eq 0 ]]; then
		print_heading
    echo "There are no partitions on the device, and we cannot continue without partitions on which to install."
    echo "'cfdisk' is available for you to create a partition table now if you wish."
		echo "If you are uncertain about partitioning, you should read the Wiki (address at the top)"
    echo "If you choose not to use 'cfdisk' the script will terminate to allow you to partition in some other way."
    read -p "Would you like to open cfdisk now? [Y/n]: " Response
    case $Response in
		  "y"|"Y"|"") cfdisk
			;;
		*) exit
		esac
 	else
    # Alternatively, offer cfdisk to edit existing partitions
		echo "Here is a list of available partitions on all connected devices ..."
		lsblk
		echo ""
		read -p "Would you like to open cfdisk to manage those partitions now? [y/n]: " Response
		case $Response in
		  "y"|"Y"|"") cfdisk
			;;
      *) echo ""
		esac
	fi
}

select_filesystem() {
# Adapted from Lution
# Allows user-selection of filesystem by entering a number
# Returns enhanced selection via FILESYSTEM variable
	Counter=0
	PS3="$prompt1"
	TypeList="Skip ext2 ext3 ext4 btrfs"	
	echo "Now select the format type for ${Partition}"
	select type in ${TypeList}
	do
    for i in ${TypeList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				PartitionType=$i
			fi
		done
		break
  done
}

AllocateRoot() {
# Display partitions for user-selection	
	# First store all available partitions in a list
	PartitionList=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	print_heading
	Remaining=""
	Counter=0
	PS3="$prompt1"
	echo "Select the partition for root:" # Display them and select one for root
	select partition in ${PartitionList}
	do
    Reply=$REPLY
    for i in ${PartitionList}
		do
		Partition=""
		PartitionType=""
		Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
				Partition="/dev/$i"
				echo "Root partition will be $Partition"
				RootPartition="${Partition}"
				select_filesystem
				if [ -z ${PartitionType} ]
				then
					RootType="ext4"
				fi
				RootType="${PartitionType}"
			else
				Remaining="$Remaining $i"	# Add next available partition
			fi
		done
    PartitionList=$Remaining			# Replace original PartitionList with remaining options
		break
  done
  if [ -n ${#PartitionList[@]} ]
  then
    print_heading
    read -p "Do you wish to allocate a swap partition? (Y/n): " Response
    case ${Response} in
    "y"|"Y"|"") print_heading
        AllocateSwap # Display remaining partitions and select one for swap
      ;;
    *) SwapPartition="Skip"
    esac
    # Check contents of PartitionList again. If not empty, call the ExtraPartitions function
    if [ -n ${#PartitionList[@]} ]
    then
      ExtraPartitions
    fi
  else
    SwapPartition="Skip"
  fi
}

AllocateSwap() {
  Remaining=""
  Counter=0
  PS3="$prompt1"
  echo -e "Select the partition for /swap from the ones that remain:\n"
  select partition in ${PartitionList}
  do
  Reply=$REPLY
    for i in ${PartitionList}
    do
    Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        SwapPartition="/dev/$i"
      else
        Remaining="$Remaining $i"	# Add next available partition
      fi
    done
    break
  done
  PartitionList=$Remaining		# Replace original PartitionList with remaining options
}

ExtraPartitions() {
# If partitions on the device remain unselected
Counter=0
Elements=${#PartitionList[@]}
while [ $Counter -le $Elements ]
do
	print_heading
	echo "The following partition(s) are still available:" ${PartitionList}
	read -p "Do you wish to allocate any of these? [y/N]: " Response
	case $Response in
		"y"|"Y") echo ""
		;;
		*) break
	esac
	Remaining=""
	PS3="$prompt1"
	echo -e "Select the partition to be allocated \n"
	select partition in ${PartitionList}
	do
		Selected=$REPLY
		for i in ${PartitionList}
		do
      Partition=""
      PartitionType=""
      Counter=$((Counter+1))
			if [ $Counter -eq $Selected ]
			then
			Partition="/dev/$i"
        # 1) When selected, first save to AddPartList (eg: /dev/sda5)
				Elements=${#AddPartList[@]}
				AddPartList[$Elements]="${Partition}"
        # 2) Then get a label for selected partition (eg: /home)
				LoopRepeat="Y"
				while [ ${LoopRepeat} = "Y" ]
				do
					echo "Enter a label for ${Partition} ... eg: '/home' ... "
          read -p "(you must include the '/'): " Response
					# Check that entry includes '/'
					CheckInput=(`echo $Response | cut -c1`)
					case ${CheckInput} in
					"") echo "You must enter a valid name"
							PartLabel=""
            ;;
					*) if [ ${CheckInput} != "/" ]
						then
							PartLabel="/${Response}"
						else
							PartLabel="${Response}"
						fi
					esac
          # Check that the label has not already been used
					LabelCounter=0
					if [ -z ${AddPartLabel} ]
					then
						LoopRepeat="N"
					else
						# Go through AddPartLabel checking each item against PartLabel
						for i in ${AddPartLabel}
						do 
							LabelCounter=$((LabelCounter+1))
							echo $i
							if [ $PartLabel = $i ] 
							then
								read -p "Label ${PartLabel} has already been used. Please use a different label." Response
							else
								LoopRepeat="N"
								break
							fi
						done 
					fi 
					if [ ${LoopRepeat} = "N" ]  
					then
						break
					fi 
				done 
  			# Add it to AddPartLabel list
 				AddPartLabel[$Elements]="${PartLabel}"
 				# Set format type for the selected partition
 				select_filesystem
				if [ -z ${PartitionType} ]
				then
					PartitionType="ext4"
				fi
				# Add it to AddPartType list
 				AddPartType[$Elements]="${PartitionType}"
 			else                            # ie: $Counter is not equal to $Selected
        if [ -n $i ]                  # Test that loop element is not empty
        then
          Remaining="$Remaining $i" 	# Add unused partition to temp list
        else                          # If it is empty ...
          break                       # ... exit loop
        fi
			fi
		done
    break
  done
	PartitionList=$Remaining		    	  # Replace original PartitionList with temp list
  if [ -z $PartitionList ]            # If PartitionList is now empty
  then
    break                             # Exit function
  fi                                  # Otherwise
  Elements=${#PartitionList[@]}       # Reset condition variables
  if [ $Elements -eq 0 ]
  then
    PartitionList=""
  fi
  Counter=0                           # And loop to top
done
# Ensure that if AddPartList (the defining array) is empty, all others are too
Elements=${#AddPartList[@]}
if [ $Elements -eq 0 ]
then
  AddPartList=""
  AddPartLabel=""
  AddPartType=""
fi
}

# User to choose device for grub installation
SetGrubDevice() {
  # Store available devices in a list	
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd') Skip";
	# Display available devices and select one for Grub
	print_heading
  GrubDevice=""
	Counter=0
	PS3="$prompt1"
	print_info "Select the device where Grub is to be installed. Note that, if you"
  print_info "select the 'Skip' option, Grub will not be installed, and you will"
  print_info "have to make alternative arrangements for booting your system."
	select partition in ${DevicesList}
	do
  Reply=$REPLY
    for i in ${DevicesList}
		do
    Item=$i
  	Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
        if [ $Item = Skip ]; then
        GrubDevice=""
        else
        GrubDevice=$Item
        fi
      break
    	fi
 		done
    break
  done
}

# Unmount partitions (from Lution/AUI - Nice code)
# 1) Gets a list of all mounted partitions into MOUNTED
# 2) Sets swap off for all devices marked as 'swap' in /etc/fstab
# 3) Unmounts each mounted device in turn from MOUNTED
umount_partitions(){
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  for i in ${MOUNTED[@]}; do
    umount $i >/dev/null
  done
  CheckForError "Line ${LINENO}"
}

MountPartitions() {
  # Root
  echo "Mounting partitions"
  echo "Formatting /root partition"
  mkfs.${RootType} ${RootPartition} # eg: mkfs.ext4 /dev/sda1
  echo "Mounting /root partition"	
  mount ${RootPartition} $MOUNTPOINT # eg: mount /dev/sda1 /mnt
  CheckForError "Line ${LINENO}"
  # Swap
  if [ ${SwapPartition} != "Skip" ]
  then
    echo "Making /swap partition"
    mkswap ${SwapPartition} # eg: mkswap /dev/sda2
    CheckForError "Line ${LINENO}"
    echo "Activating /swap"
    swapon ${SwapPartition} # eg: swapon /dev/sda2
    CheckForError "Line ${LINENO}"
  fi
  echo "Mounting additional partitions"
  Counter=0
  Elements=${#AddPartList[@]}
 	# Repeat $Elements times getting data from AddPartList AddPartLabel arrays
  while [ $Counter -lt $Elements ]
  do
    mkdir -p ${MOUNTPOINT}${AddPartLabel[$Counter]}	# eg: mkdir -p /mnt/home
    mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]} # eg: mkfs.ext4 /dev/sda3
    CheckForError "Line ${LINENO}"
    mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]}	# eg: mount /dev/sda3 /mnt/home
    CheckForError "Line ${LINENO}"
		Counter=$((Counter+1))
	done
}

# ----------------
#	End of Functions
# ----------------
