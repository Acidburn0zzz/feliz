#!/bin/bash

# achoofuncs - Various functions called by all scripts at data-entry stage

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Evo/Lution script by Carl Duff and AUI scripts by HelmuthDU.

# Please read the introduction in the README file

# -------------------------
# Functions           Line
# -------------------------
# Input and output     29
# Internet connection  163
# Mirrorlist           219
# SetScope             258
# SetKernel            282
# Menu                 233
# InfoMenu             354
# MakePartitionList    408
# -------------------------

contains_element() { # (from AUI scripts)
# check if an element exists in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    echo 
    read_timed "Invalid option. Try again ..." 1
}

print_heading() {
  clear
  T_COLS=`tput cols`
  tput cup 1 $((($T_COLS/2)-20))
  printf "~ Achoo! The Arch Linux Installation Script ~\n"
  printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_line() { # from AUI scripts
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_info() { # Aligned text according to screen size
  T_COLS=`tput cols`
  if [ $2 ]; then # Second parameter is number of characters to left of centre
    lov=$2
  else
    lov=${#1}
  fi
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( ($T_COLS - $lov) / 2 ))
    EMPTY="$(printf '%*s' $stpt)"
    echo "$EMPTY $1"
  else
    echo "$1"
  fi
}

print_list() { # Subsequent item(s) in an aligned list (menu)
    if [ $2 ]; then
      lov=$2
      stpt=$(( ($T_COLS - $lov) / 2 ))
      EMPTY="$(printf '%*s' $stpt)"
    fi
   echo "$EMPTY $1"
}

TPecho() { # For displaying status while running on auto
  echo
  CurrentTime=$(date +%s)
  Difference=$(( $CurrentTime-$StartTime ))
  DIFFMIN=$(( $Difference/60 ))
  DIFFSEC=$(( $Difference % 60 ))
  T_COLS=`tput cols`
  tput bold
  lov=${#1}
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( ($T_COLS - $lov) / 3 ))
    EMPTY="$(printf '%*s' $stpt)"
    echo -e "$EMPTY ${DIFFMIN}m ${DIFFSEC}s - $1 \n"
  else
    echo -e "${DIFFMIN}m ${DIFFSEC}s - $1 \n"
  fi
  tput sgr0
  echo
}

TPread() { # Aligned prompt for user-entry - returns result through $Response
  T_COLS=`tput cols`
  lov=${#1}
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( ($T_COLS - $lov) / 2 ))
  elif [ ${lov} -gt ${T_COLS} ]; then
    stpt=0
  else
    stpt=$(( ($T_COLS - 10) / 2 ))
  fi
  EMPTY="$(printf '%*s' $stpt)"
  read -p "$EMPTY $1" Response
}

read_timed() { # Now can receive second parameter to set duration
  T_COLS=`tput cols`
  lov=${#1}
  if [ $2 ]; then
    tim=$2
  else
    tim=2
  fi
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( ($T_COLS - $lov) / 2 ))
    EMPTY="$(printf '%*s' $stpt)"
  else
    EMPTY=""
  fi
  read -t ${tim} -p "$EMPTY $1"
  echo
}

CheckInternet() {
print_heading
Service="N"
while [ $Service = "N" ]
do
  print_info "Welcome to the Achoo! Arch Linux installation script."
  print_info "A working internet connection is needed for installation."
  print_info "Checking your connection now ..."
  CheckConnection
  case $Service in
    "N") read_timed "Sorry, installation cannot continue without an internet connection."
      exit
    ;;
    *) break
  esac
  print_heading
done
}

CheckConnection() {
while [ $Service = "N" ]
do
  if [[ ! $(ping -c 3 google.com) ]]; then
    wifi-menu
    if [[ ! $(ping -c 3 google.com) ]]; then
      print_info "Unable to establish a connection. Ensure that your computer"
      print_info "is able to access the internet."
      TPread "Try again? (y/n): "
      Retry=$Response
      if [ $Retry != "Y" ] && [ $Retry != "y" ]; then
        exit
        break
      fi
    else
      read_timed "Connection detected"
      Service="Y"
    fi
  else
    read_timed "Connection detected"
    Service="Y"
  fi
done
}

ReflectorMirrorList() {
 # Use reflector to generate fast mirror list
  TPecho "Using Reflector to generate mirrorlist"
  reflector --verbose -l 5 --sort rate --save /etc/pacman.d/mirrorlist 2>> error.log
  if [[ $? -gt 0 ]]; then
    LocalMirrorList
  else
    chmod +r /etc/pacman.d/mirrorlist 2>> error.log
  fi
}

LocalMirrorList() {
# In case Reflector fails, generate and save a shortened mirrorlist of only 
# the mirrors defined in the CountryCode variable. Adapted from Lution AIS
	TPecho "Reflector failed - generating local mirrorlist instead"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist) 2>> error.log
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL} 2>> error.log
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp} 2>> error.log
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig 2>> error.log
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist 2>> error.log
	chmod +r /etc/pacman.d/mirrorlist 2>> error.log
}

SetScope() {
  Retry="Y"
  until [ $Retry = "N" ]
  do
    print_heading
    print_info "You can continue with just a basic Arch Linux installation, "
    print_info "or Achoo can add a Desktop Environment, set up a user, and"
    print_info "automatically install codecs, wifi tools, graphics, etc"
    echo
    TPread "Add Desktop Environment, etc? (y/n): "
    echo
    case $Response in
      "y" | "Y") Scope="Full"
        ChooseDE
        PickLuxuries
        UserName
        Retry="N"
      ;;
      "") invalid_option
      ;;
      *) Scope="Basic"
        Retry="N"
    esac
  done
}

SetKernel() {
  MenuList="LTS Latest"
  print_heading
  echo
  print_info "The Long-Term-Support kernel (LTS) offers stabilty,"
  print_info "while the Latest kernel has all the new features."
  print_info "If in doubt, choose LTS."
  echo
  local Counter=0
  Menu "$MenuList" "Enter the number of your choice: " "Kernels" "nodone"
  Kernel=${Response} # Set the Kernel variable (1 = LTS; 2 = Latest)
}

Menu() {
local Complete=0
local Done=$4
print_info $3
Underscore=`echo $3 | sed 's/./-/g'`
print_info $Underscore
while [ $Complete -eq 0 ]
do
  local Counter=0
  MenuList=$1
  MenuPrompt="$2"
  for i in $MenuList
  do
    Counter=$((Counter+1))
    if [ $Counter -eq 1 ]; then
      print_info "$Counter) $i"
    else
      print_list "$Counter) $i"
    fi
    ConvertToArray[$Counter]=$i
  done
  case $Done in
    "") Counter=$((Counter+1))
        Done="Done"
        print_list "$Counter) Done"
    ;;
    "nodone") Done=""
    ;;
    *) Counter=$((Counter+1))
        print_list "$Counter) ${Done}"
  esac
  echo
  TPread "$2"
  case $Response in
    ''|*[!0-9]*) invalid_option
    ;;
    *) if [ ${Response} -gt ${Counter} ]; then
      invalid_option
      elif [ ${Response} -eq ${Counter} ]; then
        Result="$Done"
        Complete=1
      else
        Result=${ConvertToArray[${Response}]}
        Complete=1
      fi
  esac
  print_heading
done
}

InfoMenu() {
# Advanced menuing function with extended descriptions linked to short name
# Parameters: 1) Primary file; 2) Title; 3) Secondary file (long description);
# If global variable $Passed is not empty, that is displayed at the top 
local Complete=0
Result=""
PrimaryFile="$1"
name=$3[@]
LongDescription=("${!name}")
ExtraItem=$4
local Counter=0
while [ $Complete -eq 0 ]
do
  if [ -n "${Passed}" ]; then
    print_info "$Passed"
  fi
  echo
  print_info "Select one item from this list"
  echo
  print_info "$2"
  Underscore=`echo $2 | sed 's/./-/g'`
  print_info "$Underscore"
  Counter=0
  # for i in $PrimaryFile; do
  for i in "${LongDescription[@]}"; do
    Counter=$((Counter+1))
    if [ $Counter -eq 1 ]; then
      print_info "${Counter}) $i"
    else
      print_list "${Counter}) $i"
    fi
  done
  Counter=$((Counter+1))
  print_list "$Counter) Done"
  echo
  TPread "Please enter one number : "
  if [ -z ${Response} ] || [ ${Response} = ${Counter} ]; then
    Result="Done"
    Complete=1
  elif [ ${Response} -gt ${Counter} ] || [ ${Response} -lt 1 ]; then
    invalid_option
  else
    Counter=0
    for i in $PrimaryFile; do
      Counter=$((Counter+1))
      if [ $Counter -eq $Response ]; then
        Result="$i"
      fi
    done
    break
  fi
done
}

MakePartitionList() {
  # Call function to generate an array of partitions
  # This is not a first call, so first empty the existing array
   	local x=0
    local HowMany="${#PartitionArray[@]}"
    until [ ${x} -eq ${HowMany} ]
    do
      unset PartitionArray[$x]
      x=$((x+1))
    done
		BuildPartitionLists # Then rebuild
}
