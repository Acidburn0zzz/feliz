#!/bin/bash

# Achoo! Arch Linux Installation Script 2015/07/08
# achoofuncs - Functions called by the main Achoo! script
# -----------------------------------------------------------
# This script and the achoovariables script are necessary when
# running the main Achoo! script
# -----------------------------------------------------------

# Developed by Elizabeth Mills, incorporating some code adapted from the
# Evo/Lution script by Carl Duff and the AUI scripts by HelmuthDU.
#
# The Achoo! script is still in development, and may contain bugs.
# It was originally written for my own use, but it is shared in the spirit of
# the community, subject to the conditions set out in the GNU GENERAL LICENSE.
#
# Its purpose is to speed up installation of Arch Linux, plus a desktop
# environment and a greeter, with minimum user intervention.
#
# Users - You must plan your partition scheme and take care when entering
# your details, or loss of data could occur.

# ----------------
# Functions layout
# ----------------
# Input and output
# Error-checking
# Mirrorlist
# Partitioning
# Location variables
# Desktop environment
# ---------------------

# ----------------
# Input and output 
# ----------------

contains_element() { # (from AUI scripts)
# check if an element exists in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

invalid_option() { # (from AUI scripts)
    print_line
    echo 
    read -t 2 -p "Invalid option. Try another one."
}

print_heading() {
	clear
    printf "                 # - The Achoo! Arch Linux Installation Script - # \n"
    print_title "    https://github.com/Angeltoast/Achoo   ~   https://wiki.archlinux.org/"
}

print_line() { # (from AUI scripts)
    printf "%$(tput cols)s\n"|tr ' ' '-'
}

print_title() { # (from AUI scripts)
    print_line
    echo -e " ${Bold}$1${Reset}"
    print_line
    echo ""
}

print_info() { # (from AUI scripts)
    # Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 10 )) | sed 's/^/\t/'
}

read_timed() {
  echo $1
  read -t 3 -p ""
}

# --------------
# Error-checking
# --------------

CheckForError() {
# Check for stderr, display it, then exit script
	if [[ $? -gt 0 ]]; then
    clear
		echo "A fatal error was reported at $1."
    echo "The script cannot continue."
    read -n1 -p "Please press any key: "
    echo ""
		exit
	else
		echo "Preparing next step ..."
	fi
}

# -----------------------
# Mirrorlist
# -----------------------

LocalMirrorList() {
# Generate and save a shortened mirrorlist of only the mirrors defined
# in the CountryCode variable. Adapted from Lution AIS
	echo "Generating local mirrorlist"
	URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
	MirrorTemp=$(mktemp --suffix=-mirrorlist)
	CheckForError "Line ${LINENO}"
	
	# Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
	curl -so ${MirrorTemp} ${URL}
	CheckForError "Line ${LINENO}"
	
	# Use sed to filter entries
	sed -i 's/^#Server/Server/g' ${MirrorTemp}
	CheckForError "Line ${LINENO}"
	
	# Make a safe copy of existing mirrorlist
	mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
	CheckForError "Line ${LINENO}"
	
	# Replace existing mirrorlist with new local mirrorlist
	mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist
	chmod +r /etc/pacman.d/mirrorlist
	CheckForError "Line ${LINENO}"
}

# ------------
# Partitioning
# ------------

ManagePartitions() {
# Check and show partitions.	
	# First test for existing partitions
	print_heading
	ShowPartitions=""
	PARTITIONS=""
	ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	# Count the partitions
  for i in ${ShowPartitions[@]}; do
    PARTITIONS="${PARTITIONS} ${i} -"
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
  done	
	# If no partitions exist, offer cfdisk to create (or exit)
	if [[ $NUMBER_PARTITIONS -eq 0 ]]; then
		print_heading
    echo "There are no partitions on the device, and we cannot continue without at least"
    echo "one partition on which to install. 'cfdisk' is available for you to create a"
		echo "partition table now if you wish. If you are uncertain about partitioning, you"
    echo "should read the Wiki (address at the top). If you choose not to use 'cfdisk'"
    echo "now, the script will terminate to allow you to partition in some other way."
    read -p "Would you like to open cfdisk now? [Y/n]: " Response
    case $Response in
		  "y"|"Y"|"") cfdisk
			;;
		*) exit
		esac
 	else
    # Alternatively, offer cfdisk to edit existing partitions
		echo "Here is a list of available partitions on all connected devices ..."
		lsblk
		echo ""
		read -p "Would you like to open cfdisk to manage those partitions now? [Y/n]: " Response
		case $Response in
		  "y"|"Y"|"") cfdisk
			;;
      *) echo ""
		esac
	fi
  # After cfdisk, build new list of partitions
  PartitionList=" "
  ShowPartitions=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
  PartCounter=0
  for Part in ${ShowPartitions}
  do
    PartitionList="$PartitionList $Part"	# Add each partition
  done
}

select_filesystem() {
# Adapted from Lution
# Allows user-selection of filesystem by entering a number
# Returns enhanced selection via FILESYSTEM variable
	Counter=0
	PS3="$prompt1"
	TypeList="Skip ext2 ext3 ext4 btrfs"	
	echo "Now select the format type for ${Partition}"
	select type in ${TypeList}
	do
    for i in ${TypeList}
		do
		Counter=$((Counter+1))
			if [ $Counter -eq $REPLY ]
			then
				PartitionType=$i
			fi
		done
		break
  done
}

AllocateRoot() {
# Display partitions for user-selection	
	# First store all available partitions in a list
	print_heading
	echo "Here are the available partitions."
	# PartitionList=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	Remaining=""
	Counter=0
	PS3="$prompt1"
	echo "Select the one for root:" # Display them and select one for root
	select partition in ${PartitionList}
	do
    Reply=$REPLY
    for i in ${PartitionList}
		do
		Partition=""
		PartitionType=""
		Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
				Partition="/dev/$i"
				echo "Root partition will be $Partition"
				RootPartition="${Partition}"
				select_filesystem
				if [ -z ${PartitionType} ]
				then
					RootType="ext4"
				fi
				RootType="${PartitionType}"
			else
				Remaining="$Remaining $i"	# Add next available partition
			fi
		done
    PartitionList=$Remaining			# Replace original PartitionList with remaining options
		break
  done
}

AllocateSwap() {
  print_heading
  if [ -n ${#PartitionList[@]} ] # If there are remaining partitions ...
  then                         # ... offer one for swap
    echo -e "Select the partition for /swap from the ones that remain."
    Remaining=""
    Counter=0
    PS3="$prompt1"
    SwapPartition=""
    PartitionList="$PartitionList Skip"
    echo -e "If you select the 'Skip' option, no swap will be allocated:\n"
    select partition in ${PartitionList}
    do
    Reply=$REPLY
      for i in ${PartitionList}
      do
      Counter=$((Counter+1))
        if [ $Counter -eq $Reply ]
        then
          if [ $i = Skip ]; then
            SwapPartition=""
          else
            SwapPartition="/dev/$i"
          fi          
        else
          if [ $i != Skip ]; then
            Remaining="$Remaining $i"	# Add next available partition
          fi
        fi
      done
      break
    done
    if [ $SwapPartition ]; then
        read -t 2 -p "$SwapPartition will be used for swap."
    else
        read -t 2 -p "No swap partition will be allocated."
    fi
    PartitionList=$Remaining		# Replace original PartitionList with remaining options
  fi
}

ExtraPartitions() {
# If partitions on the device remain unselected
PartCounter=0
Elements=${#PartitionList[@]}
while [ $PartCounter -le $Elements ] # Display a list (including a 'Skip' option) 
do
	print_heading
	Remaining=""
	PS3="$prompt1"
  PartitionList="$PartitionList Skip"
	echo "The following partitions remain unallocated."
	echo "If you wish to use one, select it from the list."
  echo -e "Or choose 'Skip' to exit. \n"
	select partition in ${PartitionList} # User select an item from the list
	do
		Selected=$REPLY
		for Part in ${PartitionList} # Iterate through the list
		do
      Partition=""
      PartitionType=""
      PartCounter=$((PartCounter+1))
			if [ $PartCounter -eq $Selected ]
			then
        Item=$Part  # Selected item
        if [ $Item = Skip ]; then   # If item is 'Skip'
          #Counter=$Elements
          break     # Finish
        else                        # If item is not 'Skip'
        	Partition="/dev/$Item"
          MakePartition # Call MakePartition to complete details
        fi
      else                          # If $Counter is not equal to $Selected
        if [ $Part != Skip ]; then   # (and not 'Skip')
          Remaining="$Remaining $Part" # Add unused partition to temp list
        fi
			fi
    done
    if [ $Part = Skip ] || [ -z ${Remaining} ]; then  # If skip or there are no more to allocate
      break
    fi
  done
  if [ $Item = Skip ] || [ -z ${Remaining} ]; then
    break
  fi                     
  PartCounter=0
  PartitionList=$Remaining	# Replace original PartitionList with temp list
  Elements=${#PartitionList[@]}
done
# Ensure that if AddPartList (the defining array) is empty, all others are too
if [ -z ${#AddPartList[@]} ]
then
  AddPartList=""
  AddPartLabel=""
  AddPartType=""
fi
}

MakePartition() {
    # 1) When selected, first save to AddPartList (eg: /dev/sda5)
		ExtraPartitions=${#AddPartList[@]}
		AddPartList[$ExtraPartitions]="${Partition}"
    # 2) Then get a label for selected partition (eg: /home)
		LoopRepeat="Y"
		while [ ${LoopRepeat} = "Y" ]
		do
			echo "Enter a label for ${Partition} ... eg: '/home' ... "
      read -p "(you must include the '/'): " Response
			# Check that entry includes '/'
			CheckInput=(`echo $Response | cut -c1`)
			case ${CheckInput} in
        "") echo "You must enter a valid name"
						PartLabel=""
           ;;
				*) if [ ${CheckInput} != "/" ]
					then
						PartLabel="/${Response}"
					else
						PartLabel="${Response}"
					fi
      esac
      # Check that the label has not already been used
			LabelCounter=0
			if [ -z ${AddPartLabel} ]
			then
				LoopRepeat="N"
			else
				# Go through AddPartLabel checking each item against PartLabel
				for Label in ${AddPartLabel}
				do 
					LabelCounter=$((LabelCounter+1))
					if [ $Label = $PartLabel ] 
					then
						read -t 4 -p "Label ${PartLabel} has already been used. Please use a different label."
					else
						LoopRepeat="N"
						break
					fi
				done 
			fi 
			if [ ${LoopRepeat} = "N" ]  
			then
				break
			fi 
		done 
		# Add it to AddPartLabel list
		AddPartLabel[$ExtraPartitions]="${PartLabel}"
		# Set format type for the selected partition
		select_filesystem
    if [ -z ${PartitionType} ]
		then
			PartitionType="ext4"
		fi
		# Add it to AddPartType list
		AddPartType[$ExtraPartitions]="${PartitionType}"

}

# User to choose device for grub installation
SetGrubDevice() {
  # Store available devices in a list	
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd') Skip";
	# Display available devices and select one for Grub
	print_heading
  GrubDevice=""
	Counter=0
	PS3="$prompt1"
	print_info "Select the device where Grub is to be installed. Note that, if you"
  print_info "select the 'Skip' option, Grub will not be installed, and you will"
  print_info "have to make alternative arrangements for booting your system."
	select partition in ${DevicesList}
	do
  Reply=$REPLY
    for i in ${DevicesList}
		do
    Item=$i
  	Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
        if [ $Item = Skip ]; then
        GrubDevice=""
        else
        GrubDevice=$Item
        fi
      break
    	fi
 		done
    break
  done
}

# -------
# Running
# -------

arch_chroot() {
# Taken directly from Lution AIS
# Function chroots to MOUNTPOINT (/mnt) for parameter passed from caller
  arch-chroot ${MOUNTPOINT} /bin/bash -c "${1}"
  CheckForError "Line ${LINENO}"
}  

# Unmount partitions (from Lution/AUI - Nice code)
# 1) Gets a list of all mounted partitions into MOUNTED
# 2) Sets swap off for all devices marked as 'swap' in /etc/fstab
# 3) Unmounts each mounted device in turn from MOUNTED
umount_partitions(){
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  for i in ${MOUNTED[@]}; do
    umount $i >/dev/null
  done
  CheckForError "Line ${LINENO}"
}

MountPartitions() {
  # Root
  echo "Mounting partitions"
  echo "Formatting /root partition"
  mkfs.${RootType} ${RootPartition} # eg: mkfs.ext4 /dev/sda1
  CheckForError "Line ${LINENO} 'mkfs'"
  echo "Mounting /root partition"	
  mount ${RootPartition} $MOUNTPOINT # eg: mount /dev/sda1 /mnt
  CheckForError "Line ${LINENO} 'mount'"
  # Swap
  if [ ${SwapPartition} ]
  then
    echo "Making /swap partition"
    mkswap ${SwapPartition} # eg: mkswap /dev/sda2
    CheckForError "Line ${LINENO} 'mkswap'"
    echo "Activating /swap"
    swapon ${SwapPartition} # eg: swapon /dev/sda2
    CheckForError "Line ${LINENO} 'swapon'"
  fi
  echo "Mounting additional partitions"
  Counter=0
  Elements=${#AddPartList[@]}
 	# Repeat $Elements times getting data from AddPartList AddPartLabel arrays
  while [ $Counter -lt $Elements ]
  do
    mkdir -p ${MOUNTPOINT}${AddPartLabel[$Counter]}	# eg: mkdir -p /mnt/home
    mkfs.${AddPartType[$Counter]} ${AddPartList[$Counter]} # eg: mkfs.ext4 /dev/sda3
    CheckForError "Line ${LINENO}"
    mount ${AddPartList[$Counter]} ${MOUNTPOINT}${AddPartLabel[$Counter]}	# eg: mount /dev/sda3 /mnt/home
    CheckForError "Line ${LINENO}"
		Counter=$((Counter+1))
	done
}

# ------------------------------
# Locations, Names and Passwords
# ------------------------------

getkeymap() {
# New routine to enable user to input two-letter country-code to find keyboard
print_heading
DoDoDo=1
SearchPrompt="Enter the two-letter code for your country or keyboard (eg: uk): "
echo "Now we will try to find your keyboard from a list of all known layouts"
while [ $DoDoDo -eq 1 ]
do
  read -p "$SearchPrompt" search_term
  SEARCHTERM="${search_term,,}"
  KeyboardList=(`localectl list-keymaps | grep ${SEARCHTERM} | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
  for i in ${KeyboardList[@]}; do
    echo $i
  done
  read -n1 -p "Is your keyboard layout in this list? (y/n): " Response
  case $Response in
    "Y"|"y"|"") PS3="$prompt1"
      echo "Select keyboard:"
      select KEYMAP in "${KeyboardList[@]}"; do
        if contains_element "$KEYMAP" "${KeyboardList[@]}"
        then
          Countrykbd=$KEYMAP
          break
        else
          invalid_option
        fi
      done
      DoDoDo=0
    ;;
    *) SearchPrompt="Try a different two-letter code (remember, lower case): "
          print_heading
  esac
done
}

setlocale() {
# New routine to enable user to input two-letter country-code to find locale
print_heading
DoDoDo=1
SearchPrompt="Enter the two-letter code for your country or language (eg: GB): "
echo "Next we will try to find your locale"
while [ $DoDoDo -eq 1 ]
do
  read -p "$SearchPrompt" search_term
  SEARCHTERM="${search_term^^}"
  LocaleList=(`cat /etc/locale.gen | grep ${SEARCHTERM}.UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
  for i in ${LocaleList[@]}; do
    echo $i
  done
  read -n1 -p "Is your locale in this list? (y/n): " Response
  case $Response in
    "Y"|"y"|"") PS3="$prompt1"
      echo "Select locale:"
      select LOCALE in "${LocaleList[@]}"; do
        if contains_element "$LOCALE" "${LocaleList[@]}"; then
          CountryLocale="${LOCALE}.UTF-8"
          CountryCode=(`echo $LOCALE | cut -c4-6`)
          break
        else
          invalid_option
        fi
      done
      DoDoDo=0
    ;;
    *) SearchPrompt="Try a different two-letter code (remember, UPPER CASE): "
          print_heading
  esac
done
}

settimezone() {
# Variables "ZONE" and "SUBZONE" - Defaults = "Europe/London"
print_heading
print_info "Now we have to set up the best mirrors for downloading your system"
print_info "This will also be used for setting the clock during installation"
print_info "Choose the World Zone of your location from the following list"
# Set Zone and Sub-Zone from lists (from AUI)
  local _zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
  PS3="$prompt1"
  echo "Select zone:"
  select ZONE in "${_zones[@]}"
  do
    if contains_element "$ZONE" "${_zones[@]}"; then
      local _subzones=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
      print_heading
      PS3="$prompt1"
      echo "Now select your local city or Sub-Zone:"
      select SUBZONE in "${_subzones[@]}"; do
        if contains_element "$SUBZONE" "${_subzones[@]}"; then
          break
        else
          invalid_option
        fi
      done
      break
    else
      invalid_option
    fi
  done
}

UserAndRoot() {
# Accept user input of hostname, username, user password and root password
	while [ $Repeat ]
	do
		# Hostname
		Entered="ArchLinux"
		print_heading
		print_info "A hostname is needed. This will be a unique name to identify"
		print_info "your device on a network. If you do not enter one, the default"
		print_info "hostname of 'ArchLinux' will be used."
		read -p "Enter a hostname for your computer : " Entered
		case $Entered in
			"") Entered=$HostName
			;;
			*) HostName=${Entered}
		esac
		echo "Hostname set to: $HostName"
		# Username
		print_heading
		Entered="Archie"
		print_info "Next we have to deal with names and passwords."
		print_line
		print_info "If you don't create a username here, a default user called"
    print_info "'archie' will be set up"
		read -p "Enter a username (must be all lower case): " Entered
		case $Entered in
			"") Entered=$UserName
			;;
			*) UserName=${Entered}
		esac
		echo "Username set to: $UserName"
  	# User password
		print_heading
		Entered="Linux"
		print_info "Passwords should be a mixture of upper- and lower-case letters"
		print_info "plus numbers and special characters. If you do not enter"
		print_info "a user password, the default of 'Linux' will be used."
		read -p "Enter a password for $UserName: " Entered
		case $Entered in
			"") Entered=$UserPassword
			;;
			*) UserPassword=${Entered}
		esac
		echo "User password set to: $UserPassword}"
		# Root password
		print_heading
		Entered="Root"
		print_info "Now set a password for root. If you do not enter one, a default"
    print_info "password of 'Root' will be used."
		read -p "Enter a password for root: " Entered
		case $Entered in
			"") Entered=$RootPassword
			;;
			*) RootPassword=${Entered}
		esac
		echo "Root password set to: $RootPassword"
	break
	done
}

ChooseDE() {  # This is new code with option of Xfce, Gnome or skip
	Counter=0
	PS3="$prompt1"
	DEList="Gnome Xfce LXDE Skip"
  print_heading
  print_info "This installer offers only Gnome, LXDE or Xfce Desktop Environments."
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
	echo "Choose your Desktop Environment"
	select type in ${DEList}
	do
  Reply=$REPLY
  SelectedDE=type
    for i in ${DEList}
    do
      Item=$i
      Counter=$((Counter+1))
			if [ $Counter -eq $Reply ]
			then
      case $Item in
        "Gnome") DesktopEnvironment="gnome gnome-extra"
              DisplayManager="gdm"
              Greeter=""
          ;;
        "Xfce") DesktopEnvironment="xfce4 xfce4-goodies polkit-gnome"
              DMList="LightDM LXDM Skip"
              ChooseDM
              case $SelectedDM in
                "LightDM") DisplayManager="lightdm"
                  Greeter="lightdm-gtk-greeter"	
                  ;;
                "LXDM") DisplayManager="lxdm"
                  Greeter=""
                  ;;
                *) DisplayManager=""
                  Greeter=""
              esac	
          ;;
        "Gnome") DesktopEnvironment="lxde"
              DisplayManager="lxdm"
              Greeter=""
          ;;
        *) DesktopEnvironment=""
            DisplayManager=""
              Greeter=""	
 			esac
      break
			fi
		done
		break
  done
}

ChooseDM() {
  # Choice of Display Manager from list passed via DMList
  Counter=0
  PS3="$prompt1"
  print_heading
  print_info "Choose one of the following Display Managers for $SelectedDE"
  print_info "Alternatively, you can choose to skip this option. Either way, you"
  print_info "can always install something else manually later."
  echo "Choose your Display Manager"
  select type in ${DMList}
  do
  Reply=$REPLY
    for item in ${DMList}
    do
      Counter=$((Counter+1))
      if [ $Counter -eq $Reply ]
      then
        SelectedDM=$item
        break
      fi
    done
		break
  done
}

# ----------------
#	End of Functions
# ----------------
