#!/bin/bash

# achooparts - Partitioning functions called by the main achoo script

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Evo/Lution script by Carl Duff and AUI scripts by HelmuthDU.

# Please read the introduction in the README file

# -----------------------      ------------------------
# Functions         Line       Functions           Line
# -----------------------      ------------------------
# CheckParts          25       BuildPartitionLists 347
# Partitioning       101       UpdateArray         368
# Parted             131       AllocateRoot        470
# AutoPartition      136       CheckPartition      520
# AutoWarning        180       AllocateSwap        530
# RunAuto            197       SetSwapFile         569
# select_filesystem  286       MorePartitions      624
# SetLabel           306       MakePartition       675
# EditLabel          330
# -----------------------      ------------------------

CheckParts() {
	# First test for existing partitions
	ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  local Counter=0
  for i in $ShowPartitions
  do
    Counter=$((Counter+1))
  done
  PARTITIONS=${Counter}
	# If no partitions exist, offer cfdisk to create (or exit)
  if [ $PARTITIONS -eq 0 ]
  then
  	print_heading
    while [ $PARTITIONS -eq 0 ]
    do
      echo
      if [ $UEFI -eq 1 ]; then
        print_info "There are no partitions on the device, and your UEFI device"
        print_info "requires at least two. If you partition manually you must ensure"
        print_info "that you create and allocate the necessary partitions correctly."
      else
        print_info "There are no partitions on the device, and at least one"
        print_info "partition is needed for the root directory. If you are"
        print_info "uncertain about partitioning, you should read the Arch Wiki."
      fi
      echo
      print_info "Achoo can create a partition table for you, if you wish."
      print_info "Alternatively, 'cfdisk' is available for you to create one"
      print_info "yourself. If you choose 'Do nothing', the script"
      print_info "will terminate to allow you to partition in some other way."
      echo
      Partitioning # Partitioning options
      if [ $Response = "3" ]; then
        read_timed "Exiting Achoo! Hurry back, y'hear?"
        exit
      fi
      # Check that partitions have been created
      ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      Counter=0
      for i in $ShowPartitions
      do
        Counter=$((Counter+1))
      done
      PARTITIONS=${Counter}
    done
    # Call function to generate an array of partitions
		BuildPartitionLists # This is a first call
  else
    # Alternatively, offer cfdisk to edit existing partitions
    print_heading
		print_info "Here is a list of available partitions on all connected devices ..."
    echo
    # Call function to generate an array of partitions
		BuildPartitionLists # This is a first call
    Counter=0
    for part in ${PartitionList}
    do
      if [ $Counter = 0 ]; then
        print_info "${PartitionArray[$Counter]}"
      else
        print_list "${PartitionArray[$Counter]}"
      fi
      Counter=$((Counter+1))
    done
		echo
    print_info "'cfdisk' is available for you to edit them, or Achoo can"
    print_info "overwrite them with a new partition table if you wish."
    print_info "If you choose the 'Do nothing' option, the script"
    print_info "will continue with the existing partitions."
    echo
    Partitioning # Partitioning options
    # Call function to regenerate the array of partitions
    MakePartitionList
	fi
}

Partitioning() {
  local Proceed=""
  AutoPart=0 # Set flag to 'off' by default
  while [ -z $Proceed ]
  do
    print_info "1) Open cfdisk so I can partition manually"
    print_list "2) Auto-partition"
    print_list "3) Do nothing"
    echo
    TPread "Enter the number of your selection : "
    Proceed=$Response
    echo
    case $Proceed in
      1) cfdisk 2> error.log
        tput setf 0 # Change foreground colour to black temporarily to hide error message
        partprobe 2> error.log #Inform kernel of changes to partitions
        tput sgr0 # Reset colour
        ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      ;;
      2) AutoPartition
      ;;
      3) echo
      ;;
      *) invalid_option
        Proceed=""
        print_heading
    esac
  done
}

Parted() {
  parted --script /dev/${UseDisk} "$1" 2> error.log
  CheckForError "${LINENO} 'Parted ${1}'" 2
}

AutoPartition() {
# Called from option 2) within Partitioning()
AutoPart=0
until [ ${AutoPart} -gt 0 ]
do
  DiskDetails=`lsblk -l | grep 'disk' | awk '{print $1}'`
  UseDisk=$DiskDetails # If more than one, UseDisk will be first
  # Count lines. If more than one disk, ask user which to use
  local Counter=0
  CountDisks=0
  for i in $DiskDetails
  do
    Counter=$((Counter+1))
    Drives[$Counter]=$i
  done
  if [ $Counter -gt 1 ]
  then
    UseDisk="" # Reset for user choice
    while [ -z $UseDisk ]
    do
      print_heading
      print_info "There are $Counter devices available"
      print_info "Which do you wish to use for installation?"
      print_info "(Remember, this is auto-partition, and any data"
      print_info "on the chosen device will be lost)"
      echo
      Counter=0
      for i in $DiskDetails
      do
        Counter=$((Counter+1))
        print_info "$Counter) $i"
      done
      echo
      TPread "Enter the number of your selection: "
      UseDisk="${Drives[$Response]}"
      AutoWarning
    done
  else
    AutoWarning
  fi
done
}

AutoWarning() {
while :
do
  print_info "This will erase any data on the device"
  TPread "Are you sure you wish to continue? (y/n): "
  case $Response in
    "Y" | "y") RunAutoPart
      break
      ;;
    "N" | "n") UseDisk=""
      break 2
      ;;
    *) invalid_option
  esac
done  
}

RunAutoPart() {
  GrubDevice="/dev/${UseDisk}"
  EFIPartition=""
	# Get disk size
  DiskSize=`lsblk -l | grep "${UseDisk}\ " | awk '{print $4}' | sed s/G//g`
  # Create partitions and set variables for mounting
  if [ $UEFI -eq 1 ]; then
    Parted "mklabel gpt"
    if [ $DiskSize -gt 18 ]; then
      Parted "mkpart ESP fat32 1MiB 1GiB"
      EFIPartition="${GrubDevice}1"
      Parted "set 1 boot on"
      Parted "mkpart primary linux-swap 1GiB 4GiB"
      SwapPartition="${GrubDevice}2"
      MakeSwap="Y"
      Parted "mkpart primary ext4 4GiB 100%"
      RootPartition="${GrubDevice}3"
      RootType="ext4"
    elif [ $DiskSize -gt 10 ]; then
      Parted "mkpart ESP fat32 1MiB 1GiB"
      EFIPartition="${GrubDevice}1"
      Parted "set 1 boot on"
      Parted "mkpart primary ext4 1GiB 100%"
      RootPartition="${GrubDevice}2"
      RootType="ext4"
      SwapFile="2G"
      SwapPartition=""
    else # If disk < 10 Gb
      Parted "mkpart ESP fat32 1MiB 500MiB"
      EFIPartition="${GrubDevice}1"
      Parted "set 1 boot on"
      Parted "mkpart primary ext4 500MiB 100%"
      RootPartition="${GrubDevice}2"
      RootType="ext4"
      SwapFile="2G"
      SwapPartition=""
    fi
      ShowPart1=`lsblk -l | grep "${UseDisk}1" | awk '{print $4}'` >/dev/null
      ShowPart2=`lsblk -l | grep "${UseDisk}2" | awk '{print $4}'` >/dev/null
      ShowPart3=`lsblk -l | grep "${UseDisk}3" | awk '{print $4}'` >/dev/null
  else
    Parted "mklabel msdos"
    if [ $DiskSize -gt 18 ]; then
      Parted "mkpart primary linux-swap 1MiB 4GiB"
      SwapPartition="${GrubDevice}1"
      MakeSwap="Y"
      Parted "mkpart primary ext4 4GiB 100%"
      Parted "set 2 boot on"
      RootPartition="${GrubDevice}2"
      RootType="ext4"
    elif [ $DiskSize -gt 10 ]; then
      Parted "mkpart primary linux-swap 1MiB 2GiB"
      SwapPartition="${GrubDevice}1"
      Parted "mkpart primary ext4 2GiB 100%"
      Parted "set 2 boot on"
      RootPartition="${GrubDevice}2"
      RootType="ext4"   
      SwapFile="2G"
      SwapPartition=""
    else # If disk < 10 Gb
      Parted "mkpart primary ext4 1MiB 100%"
      Parted "set 1 boot on"
      RootPartition="${GrubDevice}1"
      RootType="ext4"
      SwapFile="2G"
      SwapPartition=""
    fi
      ShowPart1=""
      ShowPart2=`lsblk -l | grep "${UseDisk}1" | awk '{print $4}'` >/dev/null
      ShowPart3=`lsblk -l | grep "${UseDisk}2" | awk '{print $4}'` >/dev/null
  fi
  AutoPart=1 # Set flag to 'on' for mounting 
  print_heading
  print_info "Partitioning of ${GrubDevice} successful"
  print_info "-------------------------------------"
  if [ $UEFI -eq 1 ]; then
    print_info "EFI: ${EFIPartition} $ShowPart1                  "
  else
    print_info "                                                 "
  fi
  print_list "Swap: ${SwapPartition}${SwapFile} $ShowPart2"
  print_list "Root partition: ${RootPartition} ${RootType} $ShowPart3"
  echo
  print_info "You will have the opportunity to review these later."
  echo
  print_info "Press any key to continue"
  read -n1
}

select_filesystem() {
# Allows user-selection of filesystem by entering a number
	local Counter=0
  #	TypeList now passed as string by caller
	print_info "Please now select the file system for ${Partition}"
	print_info "It is not recommended to mix the btrfs file-system with others."
  echo
	Menu "${TypeList}" "$Prompt1" "Filesystems"
  for i in ${TypeList}
	do
    Counter=$((Counter+1))
		if [ $Counter -eq $Response ]
		then
			PartitionType=$i
      break
		fi
	done
}

SetLabel() {
# To build an associative array of partitions
# The array (LabellingArray[]) is declared in achoorunning with other variables
# This function should be called from the root, swap and extra partitions routines
# ... each passing a single argument containing the partition ID
#
PartitionID=$1
local HowMany="${#PartitionArray[@]}"
local x=0
until [ ${x} -eq ${HowMany} ]
do
  CompareID=`echo ${PartitionArray[${x}]} | awk '{print $1}'`
  if [ -z ${CompareID} ]; then
    x=$((x+1))
    continue
  fi
  if [ ${CompareID} = ${PartitionID} ]; then # If the partition is in the array, it has a label
  #  Label=`echo ${PartitionArray[${x}]} | awk '{print $4}'` # Save the label
  Label=`echo ${PartitionArray[${x}]}`
  fi
  x=$((x+1))
done
}

EditLabel() {
  # Uses $Label from previous function
Label="${Labelled[$1]}"
if [ -n ${Label} ]; then
  # Inform the user and accept input
  print_heading
  echo
  print_info "The partition you have chosen is labelled '${Label}'"
  echo
  print_info "If you wish to keep that label, enter 1            "
  print_list "If you wish to delete the label, enter 2"
  print_list "If you wish to enter a new label, type it at the prompt"
  echo
  TPread "Enter 1, 2 or a new label: "
  # Save to the -A array
  case $Response in
    1) LabellingArray[$PartitionID]=$Label
    ;;
    2) LabellingArray[$PartitionID]=""
    ;;
    *) LabellingArray[$PartitionID]=$Response
  esac
fi
}

BuildPartitionLists() {
  # 1) First get a list of all partitions up to sda99 | select first field | remove /dev/ | remove colon 
  ListTypeIDs=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $1}' | cut -c 6- | sed s/://g`
  # Then get matching list of types, removing unwanted text (TYPE=) and quotes 
  ListTypes=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $(NF-1)}' | cut -c 6- | sed s/\"//g` 
  # Add records from those two indexed arrays into the associative array
  local Counter=0
  for i in ${ListTypeIDs} 
  do
    x=0
    for l in ${ListTypes}
    do
      if [ $x -eq $Counter ]; then
        FileSystem[$i]=$l # ... get the matching type
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
# 2) Use blkid again to find all up to sda99 with LABEL | select first field | remove /dev/ | Remove colon
  ListLabelledIDs=`sudo blkid /dev/sd* | grep LABEL | awk '{print $1}' | cut -c 6- | sed s/://g`
  # If at least one labelled partition found, get a matching list of labels (remove quotes)
  if [ -n "$ListLabelledIDs" ]; then
    ListLabelledLabels=`sudo blkid /dev/sd* | grep LABEL | awk '{print $2}' | cut -c 7- | sed s/\"//g`
  fi
  # Add records from those two indexed arrays into associative array
  Counter=0
  for i in ${ListLabelledIDs}
  do
    x=0
    for l in ${ListLabelledLabels}
    do
      if [ $x -eq $Counter ]; then
        Labelled[$i]=$l # ... get the matching label
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  local HowManyLabelled="${#Labelled[@]}"
# 3) Find any partitions flagged as bootable
  ListAll=`sudo sfdisk -l | grep /dev | grep '*' | awk '{print $1}' | cut -c 6-`
  declare -a Flagged
  Counter=0
  for i in $ListAll
  do
    Flagged[${Counter}]="$i"
    Counter=$((Counter+1))
  done
  local HowManyFlagged="${#Flagged[@]}"
# 4) Prepare list of short identifiers (sda1 sda2 ...)
  PartitionList="" 
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
# 5) Run through short identifiers, checking the three arrays for a match
  Counter=0 # For count of partitions
  Label=""
  for part in ${ShowPartitions}
  do
  # First test Flagged
    local x=0
    until [ ${x} -eq ${HowManyFlagged} ]
    do
      if [ $part = "${Flagged[$x]}" ]; then
        Bootable="(Bootable)"
        break
      else
        Bootable=""
      fi
      x=$((x+1))
    done
    # Next test Labelled
    ThisPart=${Labelled[${part}]} # Find the record in Labelled that matches the current iteration
    if [ -n "${ThisPart}" ]; then
      Label="${ThisPart}"
    fi
    # Finally get the filesystem type
    ThisPart=${FileSystem[${part}]} # Find the record in FileSystem that matches the current iteration
    LongID=`lsblk -l | grep ${part} | awk '{print $1 " " $4 " " $7}'`
    PartitionArray[${Counter}]="$LongID $ThisPart ${Label} ${Bootable}"
    Label=""
    # Save the short ID for later functions
    PartitionList="${PartitionList} ${part}"
    Counter=$((Counter+1))
  done
  PARTITIONS=${Counter}
}

UpdateArray() { # Remove the selected partition from $PartitionArray[]
	local Counter=0
  # Empty NewArray
    local HowMany="${#NewArray[@]}"
    local x=0
    until [ ${x} -eq ${HowMany} ]
    do
      unset NewArray[$x]
      x=$((x+1))
    done
  # Build NewArray without partition selected in calling function
    for p in "${PartitionArray[@]}"
    do
      First=`echo $p | cut -c 1-5`
      if [ ${Result} != ${First} ]; then
        NewArray[${Counter}]="$p"
        Counter=$((Counter+1))
      fi
    done
  # Then copy NewArray into PartitionArray
    Counter=0
    for p in "${NewArray[@]}"
    do
      PartitionArray[${Counter}]=${NewArray[$Counter]}
      Counter=$((Counter+1))
    done
    unset PartitionArray[$Counter] # Delete the last element
}

AllocateRoot() {
  # Display partitions for user-selection	
	# Uses list of all available partitions in PartitionList
	print_heading
	Remaining=""
	local Counter=0
  Partition=""
	PartitionType=""
	print_info "Please now select a partition to use for root."
  echo
  InfoMenu "$PartitionList" "Partitions" "PartitionArray"
  Reply=$Response
  if [ $Result != "Done" ]; then
    PassPart=$Result
    SetLabel "$Result"
    UpdateArray # Remove the selected partition from $PartitionArray[]
  fi
  Counter=0  
  for i in ${PartitionList}
  do
		Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]; then
			Partition="/dev/$i"
			RootPartition="${Partition}"
      # Before going to select_filesystem, check the partition
      CheckPartition
      if [ ${CurrentType} ]; then
        print_info "You can choose to leave it as it is, by selecting 'Done', but"
        print_info "be aware that not reformatting the root partition can have"
        print_info "unexpected consequences."
        echo
        TypeList="ext2 ext3 ext4 btrfs"	
      else
      	TypeList="ext2 ext3 ext4 btrfs"	
      fi
      # Now select a filesystem
 			select_filesystem
			if [ -z ${PartitionType} ]
			then
				RootType="ext4"
			else
        RootType="${PartitionType}"
      Label="${Labelled[${PassPart}]}"
      if [ -n "${Label}" ]; then
        EditLabel $PassPart
      fi
      fi
		else
			Remaining="$Remaining $i"	# Add next available partition
		fi
	done
  PartitionList=$Remaining			# Replace original PartitionList with remaining options
}

CheckPartition() {
# Finds if there is an existing file system on the selected partition
print_heading
CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
if [ ${CurrentType} ]; then
  print_info "The selected partition ${Partition} is currently formatted to ${CurrentType}"
  print_info "Reformatting it will remove all data currently on it."
fi
}

AllocateSwap() {
# Checks if remaining partitions and allows selection for swap
print_heading
if [ -n "${PartitionList}" ]
then
  print_info "Select a partition for /swap from the ones that remain,"
  print_info "or you can allocate a swap file."
  print_info "Warning: Btrfs does not support swap files."
  echo
  Remaining=""
  local Counter=0
  SwapPartition=""
  PickFrom="$PartitionList Swapfile"
  SwapFile=""
  declare -a CopyArray # For passing to InfoMenu
  local Counter=0
  for p in "${PartitionArray[@]}"
  do
    CopyArray[${Counter}]=${PartitionArray[$Counter]}
    Counter=$((Counter+1))
  done
  CopyArray[${Counter}]="Swapfile"
  print_info "If you select the 'Done' option, no swap will be allocated:"
  echo
  InfoMenu "$PickFrom" "Partitions" "CopyArray"
  Reply=$Response # Number of selected item
  if [ $Result != "Swapfile" ] && [ $Result != "Done" ]; then # Short ID of selected item
    PassPart=$Result
  fi
  echo
  Counter=0
  for i in ${PickFrom}
  do
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]
    then
      case $i in
        "Done") SwapPartition=""
              break
        ;;
        "Swapfile") SetSwapFile
            SwapPartition=""
            break
        ;;
        *) SwapPartition="/dev/$i"
         # IsSwap=`lsblk -l | grep $i | grep SWAP | awk '{print $7}'`
          IsSwap=`sudo blkid /dev/sd* | grep 'swap' | awk '{print $1}'`
          if [ -n "$IsSwap" ]; then
            print_info "$i is already formatted as a swap partition"
            TPread "Do you wish to reformat it? (Y/n) : "
            case $Response in
              "y" | "n") MakeSwap="${Response^^}"
              ;;
              "Y" | "N") MakeSwap=${Response}
              ;;
              *) MakeSwap="Y"
            esac
          fi
          Label="${Labelled[${PassPart}]}"
          if [ -n "${Label}" ]; then
            EditLabel "$PassPart"
            SetLabel "$PassPart"
          fi
          UpdateArray # Remove the selected partition from $PartitionArray[]
      esac          
    else
      if [ $i != "Done" ] && [ $i != Swapfile ]; then
        Remaining="$Remaining $i"	# Add next available partition
      fi
    fi
  done
  if [ $SwapPartition ]; then
    read_timed "$SwapPartition will be used for swap" 1
  elif [ $SwapFile ]; then
    read_timed "A swap file of ${SwapFile} will be allocated." 1
  else
    read_timed "No swap option has been allocated." 1
  fi
  echo
  PartitionList=$Remaining	# Replace original PartitionList with remaining options
fi
}

SetSwapFile() {
# If user chooses to have a swap file instead of swap partition
LoopRepeat="Y"
while [ ${LoopRepeat} = "Y" ]
do
	print_info "Allocate the size of your swap file (M = Megabytes, G = Gigabytes)"
  TPread "Size of swap file [eg: 512M or 2G]: "
  RESPONSE="${Response^^}"
	# Check that entry includes 'M or G'
	CheckInput=(`echo $RESPONSE | grep "G\|M"`)
  echo
	if [ -z ${CheckInput} ]; then
    print_info "You must include M or G"
		SwapFile=""
	else
    SwapFile=$RESPONSE
    LoopRepeat="N"
  fi
  if [ ${LoopRepeat} = "N" ]  
  then
    break
  fi 
done 
}

MorePartitions() {
local Elements=0
AddedToRemaining=0
for i in ${PartitionList}
do
  Elements=$((Elements+1))
done
while [ $Elements -gt 0 ]  
do
	print_heading
	Remaining=""
	print_info "The following partitions remain unallocated."
  print_info "If you wish to use one, select it from the list,"
  print_info "or choose 'Done' to finish partitioning."
  echo
  InfoMenu "$PartitionList" "Partitions" "PartitionArray"
  if [ $Result != "Done" ]; then
    PassPart=$Result
    SetLabel "$Result"
    UpdateArray # Remove the selected partition from $PartitionArray[]
  fi
  echo
	for Part in ${PartitionList} # Iterate through the list
	do
    Partition=""
    PartitionType=""
    if [ $Part = $Result ] && [ $Result != "Done" ]; then
     	Partition="/dev/$Part"
      MakePartition # Call complete details
      Label="${Labelled[${PassPart}]}"
      if [ -n "${Label}" ]; then
        EditLabel $PassPart
      fi
    elif [ $Part != "Done" ]; then   # Part is not selected and not 'Done'
      Remaining="$Remaining $Part" # Add unused partition to temp list
      AddedToRemaining=$(($AddedToRemaining+1))
    fi
  done
  PartitionList=$Remaining	# Replace original PartitionList with temp list
  if [ $Result = "Done" ]; then
    Elements=0
    break
  else
    Elements=$AddedToRemaining
  fi
done
# Ensure that if AddPartList (the defining array) is empty, all others are too
if [ -z ${#AddPartList[@]} ]
then
  AddPartList=""
  AddPartMount=""
  AddPartType=""
fi
}

MakePartition() { # Called by MorePartitions
  # This function adds the selected partition to the array for extra partitions
  # And allows selection of format type and mountpoint
  # 1) When selected, first save to AddPartList (eg: /dev/sda5)
	ExtraPartitions=${#AddPartList[@]}
	AddPartList[$ExtraPartitions]="${Partition}"
  CheckPartition   # Before going to select_filesystem, check the partition
  if [ ${CurrentType} ]; then
    print_info "You can choose to leave it as it is, by selecting 'Done', but not"
    print_info "reformatting an existing partition can have unexpected consequences."
    echo
  fi
  # 2) Select filesystem
  TypeList="ext2 ext3 ext4 btrfs" # Set format types for the selected partition
	select_filesystem
	AddPartType[$ExtraPartitions]="${PartitionType}" 	# Add it to AddPartType list  
  # 3) Then get a mountpoint for it
	LoopRepeat="Y"
	while [ ${LoopRepeat} = "Y" ]
	do
    echo
		print_info "Enter a mountpoint for ${Partition} ..."
    TPread "eg: '/home' ... /"
 		# Check that entry includes '/'
		CheckInput=(`echo $Response | cut -c1`)
		case ${CheckInput} in
      "") print_info "You must enter a valid name"
					PartMount=""
          ;;
			*) if [ ${CheckInput} != "/" ]; then
						PartMount="/${Response}"
				else
						PartMount="${Response}"
				fi
    esac
    # Check that the mountpoint has not already been used
		MountPointCounter=0
		if [ -z ${AddPartMount} ]; then
			LoopRepeat="N"
		else
      # Go through AddPartMount checking each item against PartMount
			for MountPoint in ${AddPartMount}
			do 
				MountPointCounter=$((MountPointCounter+1))
				if [ $MountPoint = $PartMount ]; then
					read_timed "Mountpoint ${PartMount} has already been used. Please use a different mountpoint."
				else
					LoopRepeat="N"
					break
				fi
			done 
		fi 
		if [ ${LoopRepeat} = "N" ]  
		then
			break
		fi 
	done 
	AddPartMount[$ExtraPartitions]="${PartMount}" 	# Add it to AddPartMount list
}
